# Cherno C++ 课程笔记

YouTube原版链接：[Welcome to C++ (youtube.com)](https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb)

B站神经元猫中文字幕版链接：[神经元猫的个人空间-神经元猫个人主页-哔哩哔哩视频 (bilibili.com)](https://space.bilibili.com/364152971/channel/collectiondetail?sid=13909)

下面是自己记录的一些。

[TOC]

手动目录！！！

[1. C++是如何工作的](#5. C++是如何工作的)

[2. C++编译器是如何工作的](#6. C++编译器是如何工作的)

\3. C++链接器是如何工作的

\4. C++变量

\5. C++函数

\6.  C++头文件

\7.  如何在Visual Studio中调试

\8.  C++条件与分支(if 语句)

\9.  Visual Studio的设置

\10. C++循环(for、while)

\11. C++控制流语句

\12. C++指针

\13. C++引用

\14. C++类

\15. C++类与结构体对比

\16. 如何写一个C++类

\17. C++中的静态(static)

\18. C++类和结构体中的静态(static)

\19. C++中的局部静态(Local Static)

\20. C++枚举

\21. C++构造函数

\22. C++析构函数

\23. C++继承

\24. C++虚函数(这一节很难，多看几遍)

\25. C++接口(纯虚函数)

\26. C++可见性

\27. C++数组

\28. C++字符串

\29. C++字符串字面量

\30. C++中的const (好难，建议再看一遍)

\31. C++的mutable关键字

\32. C++的成员初始化列表

\33. C++的三元操作符

\34. 创建并初始化C++对象

\35. C++ new关键字

\36. C++隐式转换与explicit关键字

\37. C++运算符及其重载

\38. C++的this关键字

\39. C++的对象生存期(栈作用域生存期)

\40. C++的智能指针

\41. C++的复制与拷贝构造函数

\42. C++的箭头操作符

\43. C++的动态数组(std:Vector)

\44. C++的std:vector使用优化注

\45. C++中使用库(静态链接)

\46. C++中使用动态库

\47. C++中创建与使用库

\48. C++中如何处理多返回值

\49. C++的模板

\50. C++的堆与栈内存的比较



# 5. C++是如何工作的

源文件 -> 编译器 -> 编译器将其转变为二进制的东西，*例如某种库或可执行的程序*。

## 5.1 可执行程序

```C++
#include <iostream> //在#后面的都是预处理语句，编译器在实际编译之前就会处理这些语句
                    //include:需要查找文件，例如叫 iostream 的文件，然后将该文件所有内容拷贝到当前文件中，称作头文件
                    //iostream:标准输入输出流函数，包含cout、cin等等，std::cout :可以让我们在终端打印东西
int main()          //main函数是程序的入口，计算机以main函数为入口，逐行执行代码，此处定义main函数返回值是int类型，main函数可以无返回值（此时默认返回0）
{
   std::cout << "Hello world!" << std::endl;//<<:左移运算符重载，可看作函数
                                            //将字符串Hello world!推送到cout流中，然后打印到终端，然后推送一个行结束符endl，终端跳到下一行
   //std::cout.print("Hello world!").print(std::endl);
   std::cin.get(); //cin.get函数：等待enter键按下，在前往下一句代码之前等待，此时程序暂停执行直到enter键按下
                    //程序执行完毕，返回0
}                   
```

## 5.2 主要过程

1. 编译器首先执行预处理。      
2. 编译文件，编译器将所有C++代码转化为实际机器代码，头文件不会被编译，因为在预处理时已经被包含了，编译CPP时，包含进来的头文件也一起被编译。
3. 每一个cpp文件都被编译成相应的目标文件，vs生成目标文件后缀名为.obj。
4. link: 链接，将所有目标文件obj合并成一个可执行文件exe。

## 注: 

1. 在C++中，任何的符号都需要申明。
**申明**：宣告某个函数或符号是存在的，链接器会找到正确声明的函数，将函数定义导入到所声明的函数中，从而被cpp文件调用，如果找不到，就会出现链接错误。
**定义**：写出这个函数到底是什么，是函数的函数体。
2. 出现无法解析的外部命令，就是链接失败。

# 6. C++编译器是如何工作的

编译：将文本文件转化为一种叫做目标文件的中间格式，用于后续链接器进行链接。

## 6.1 主要过程

1. 首先预处理代码。常用的预处理语句有：include、if、ifdef、pragma语句。
2. 进行记号化和解析，即将 C++ 语言整理成编译器能够真正理解和推理的格式，也就导致了所谓的抽象语法树被创建（抽象语法树是代码的一种表示方式）。
3. 编译器转换我们所有的代码，成为常量数据或指令，一旦编译器创建了这个抽象语法树，它就可以开始实际生成代码，这段代码就是实际的机器码，同时还会得到一些别的数据，例如一个存储所有常量和变量的地方。

## 6.2 预处理

以 include 为例：#include 指定了想要包含的文件，预处理器打开那个文件，阅读其中所有内容，然后把它粘贴到你写的文件中。

## 注：

1. 在 C++ 中，文件只是提供给编译器源代码的一种方式。
2. if 预处理语句可以让我们包含或排除基于给定条件的代码。

# 7. C++ 链接器是如何工作的

其主要是找到每个符号和函数在哪里，并把它们连接起来。

## 7.1 主要过程

1. 链接是一个过程，从源 C++ 文件转到实际的可执行文件二进制文件。第一阶段是编译源文件，编译之后需要通过链接这一过程。
2. 每个文件都被编译成一个单独的目标文件，一个翻译单元，彼此之间没有关系，不能进行交互，所以需要通过连接才能成为一个项目，这就是链接器需要做的工作。

## 7.2 链接错误

1. LNK2019无法解析的外部符号：一种链接错误类型。
2. 未解决的外部符号unresolved external symbol：当链接器找不到它需要的东西时发生。
3. error C2084 函数已有主体/找到一个或多个定义符号：
   一种常见的链接错误类型：有重复的符号，例如有函数或变量、有相同的名字和相同的签名。
   也就是说：两个名字相同的函数有相同的返回值和相同的参数。

## 注

1. 在定义的函数前加 static 意味着在链接这个函数时只能作为内部函数，也就是说就算别的cpp文件中声明了这个函数，也无法被链接。
*这样做的好处是如果有两个cpp文件中都有同一个相同的函数，链接时就不会发生错误，而是会产生各自版本的这个函数，它对其他的obj文件都不可见。*

2. 或加 inline：获取我们实际的函数体并将函数调用替换为函数体。

# 8. C++ 变量

创建变量用于存储所利用的数据，而这个变量将被存储在内存中，堆和栈。

变量会占用一定的内存，那也是我们实际存储数据的地方。

声明一个变量：**变量类型 变量名**

## 8.1 原始数据类型

基本数据类型构成了我们在程序中存储的任何数据。

类型 | 大小 | 声明及赋值方式
:- |  :-:| :-:
**int** 整型 | 4 字节 | `int var = 4`
**char** 字符型 | 1 字节 | `char var = 'A'`
**float** 浮点型（小数） | 4 字节 | `float var = 5.5f `
**double** 双精度浮点型 | 8 字节 | `double var = 5.5 `
**bool** 布尔型 | 1 字节 | `bool var = true //bool 类型非0(false)即1(true)`
**……** |  

- 还可以在任意一个类型前添加**unsigned**，从而移除符号位，获得更大的表示范围。

## 8.2 sizeof

由于数据类型的大小依赖于编译器，可在 C++ 中用操作符 **sizeof** 来查询大小，单位是字节。
例如：sizeof(bool) = 1、sizeof(double) = 8

## 8.3 类型转换

在基本类型的基础上，可以创建任何的类型，并存储我们的任何数据。我们还可以将其转换为指针或引用。

**指针**：用\*来声明，例如 bool* var

**引用**：用\&来代表，例如 bool& var

## 注

1. 数据类型的实际大小取决于编译器，同一数据类型在不同的编译器里的大小不尽相同。

   16 位系统下 int 是 2 个字节（16 位），32 位系统才 int 占 4 个字节（32 位）。
2. 变量的类型大小与它能存储多大的数字直接相关
3. 关键字 unsigned 在 C++ 中的作用： 定义没有符号位的数据类型
4. bool 类型占一个字节而不是 1 bit 的原因：计算机在寻址时的最小单位是字节，但有方法可以使得在 1 字节内存储 8 个 bool 数。

# 9. C++ 函数

函数就是我们写的代码块，被设计用来执行特定的任务。使用函数调用可以用于避免代码块的重复。
下面是一个简单的乘法函数

```C++
void Multiply (int a, int b)//int是函数返回参数的类型，如果不需要返回值，通过void来实现
{
   int result = a * b;
   std::cout << result << std::endl;//将结果打印出来
}
```

调用这个函数:

```C++
int main()
{
   Multiply (3,4);//传入参数 a=3, b=4
   Multiply (3,5);//可对函数进行多次调用 
   std::cin.get();
}
```

- 每次调用函数时，编译器生成一个call指令。这意味着在程序运行过程中为了调用函数，需要创建一个堆栈结构，将参数推进堆栈；还需要一个返回地址，压入堆栈，然后跳到指定部分来执行我们的函数指令，为了将结果返回，还需要回到最初调用函数之前。
- 因此调用函数会减慢我们的程序运行速度。
- 出现这种问题是因为编译器决定保持我们的函数作为一个实际的函数，并不做内联inline工作。
- 我们通常将函数分解为**声明**和**定义**。声明通常储存在头文件中，在翻译单元或 cpp 文件中编写定义。

## 注

1. 我们可以给函数提供参数，函数可以返回值。函数可以没有参数也没有返回值。
2. 有返回类型的函数需要返回值，主函数除外。主函数是一个特殊函数，它会自动假设返回 0。
3. 如果在 release 模式下编译，函数没有返回值可能不会被报错，但这并不意味着没有错误。当使用这个函数时，会得到“未定义的行为”的报错信息。

# 10. C++ 头文件

就 C++ 而言，头文件通常用于声明某些类型的函数，以便能被使用在程序中。在头文件中函数没有实际的定义，即没有函数体。

- 通过 #include 预处理器指令来实现头文件内容的复制和粘贴。
- 引用头文件： **#include "×××.h"**

## 10.1 编辑头文件

头文件后缀名为 **.h**，利用 VS 创建头文件时会自动插入代码 #pragma once 。

- **#pragma once** 本质是一个预处理命令，代表**仅包含这个文件一次**，从而阻止单个头文件多次被包含，并转换为单个翻译单元。但是这并不妨碍头文件被放到程序的多个位置。
- 头文件仅对函数进行声明。
- 对函数的定义在源文件中进行，后缀名为 **.cpp**。

## 10.2 头文件保护符

\#pragma once 本质是做头文件的监督的，还有另一种更有意义的方法，就是 **ifndef**（*if not define*）。

```C++
#ifndef _LOG_H //将要定义的函数放在 ifndef 和 endif 中间，编译时会自动进行检查
#define _LOG_H //如果已经被定义了，那么就不会被包含进来

#endif
```

## 10.3 头文件差异

头文件在 include 语句中有两种情况，一种使用引号 " "，一种使用尖括号 < >。

- 尖括号是内部文件（只用于编译器包含路径），引号是外部文件（相对于当前文件的文件）。
- 使用引号，来指定编译器包含目录的相对路径里面的文件，引号虽然万能，但通常只用于相对路径。

可见 #include \<iostream> 没有扩展名.h ，表明这存在于 C++ 标准库里，**C 标准库通常有 .h 扩展，但 C++ 没有**。

## 注

1. VS 里面显示的文件夹（头文件、源文件……）只是过滤器，不是真正的文件夹。
2. 以 **#** 开头的都是预处理命令。
3. 如果我们不小心多次包含了一个文件，并转换为一个翻译单元，会得到 duplicate 复制错误。
4. 结构体 **struct** 名字必须是唯一的，如果没有#pragma once，多次包含头文件时会出现报错。

# 11. 如何在 Visual Studio 中调试

debug 调试的目的是从代码中清除错误，**断点**和**读取内存**是调试的两大部分。

## 11.1 断点

断点是程序中调试器将中断的点，break(暂停)。

- 设置好断点后运行程序，程序执行到断点时将暂停，它会挂起执行线程。此时我们可以查看内存情况。
- 通过查看内存，可以看到每一个变量的值。
- 通过设置断点，你可以单步执行，还可以 step into (步入)函数内，看程序运行到了哪里。

例如：

```C++
int main()
{
	Log("hello world");//在此处设置断点
	std::cin.get();
}
```

**step into** 逐语句： 如果这行有函数的话，进入到这行代码的函数里面。即 Log 函数内。

**step over** 逐过程：从当前函数跳到下一行代码。即`std::cin.get()`中。

**step out** 跳出：跳出当前函数，回到调用这个函数的位置。即 main 函数的调用位置，也就是 C++ 标准库函数的位置。

**continue** 继续：当面临循环时，想将整个循环执行完毕后运行下一行代码，就不可以使用 **step out** 来跳出函数，这样会导致函数没有执行完就退出了。

可以通过在函数的下一行代码处设置断点，然后 **continue** 运行程序，直到碰到下一个断点。

## 11.2 查看内存

VS 右下角视图有 3 个选项：自动窗口（autos）、局部变量（local）和监视（watch）。

- auto 和 locals 向你展示可能很重要的局部变量或变量。
- watch 让我们观察变量，在监视窗口添加要监视的项后，就可以看到显示的值。

### 内存窗口

通过 调试 -> 窗口 -> 内存 -> 内存 1 可以调出内存窗口

- 通过在地址栏输入 取地址符&加要查看的项，例如 &a 可以查看变量 a 在内存中的地址和内容。

## 注

1. 在空行上设置断点时没有用的，确保在将会被执行的代码行上设置断点。
2. 设置断点后，确保在调试（debug）模式下运行，因为 release 模式下时编译器实际上会改变代码，断点可能永远不会被击中。
3. 黄色箭头：指向将要执行的下一条语句，但此时还未被执行。
4. 不设置断点也可以单步执行，从第一行开始。

# 12. C++ 条件与分支（if 语句）

类似于 if 之类的条件语句可以产生分支，告诉电脑跳到指定的部分内存去执行相应指令。简言之就是：**检查条件，然后跳到内存的不同地方，并从这里开始执行指令。**

if 语句比较的结果是 bool 类型，只有 true 和 false 两种结果。

例子：

```C++
int main()
{
	int x = 5;
	bool comparison = x == 5;//== 等号运算符，为了检验 x 是否等于 5 
                             //= 赋值运算符。
	if (comparison)
	{
		Log("hello world");//如果comparison 为 true ,则执行 Log 语句。 
	}
	std::cin.get();
}
```

- **==** 操作符之所以这样工作是因为它在 C++ 标准库中被重载了，这就像是写一个函数，接受两个整数参数，然后检查这两个整数的内存以确保它们是相等的，相等则返回 true 。
- 可将上面的过程简化为 `if (x == 5) Log("hello world");` ，这里进行了参数折叠。

if 一般跟 else if 和 else 连用，例如：

```C++
int main()
{
	const char* ptr = nullptr;
	if (ptr)
		Log(ptr);
	else if (ptr == "hello")
		Log("ptr is hello");
	else
		Log("ptr is null");
	std::cin.get();
}
```

- else if 实则是 else 和 if，即else 语句后执行 if ，也就是说：其实没有所谓的 else if 语句，知识将两个语句放在一行而已。

## 注

1. if 语句和分支通常有比较大的开销，较影响性能，尽量避免使用。
2. **if** 语句实际上是比较 if 里面的条件是否 = 0 ,如果等于 0 就跳到下一段代码行，不等于 0 就执行 if 的分支。

   例如 `if(true){ }`，因为 true 不等于 0 ，所以执行 if 的分支，即 {} 内的内容。

   例如 `if (5==3){ }`，因为 5==3 返回的值是 false（0），if 判断 false 等于 0 ，因此跳到 if 语句段后的代码，而不执行 if 的分支 {} 。
3. 不建议一行代码里存在两条指令，因为编译器是按行执行的，逐行写便于调试代码。
4. 因为 if 语句实质是比较数值，所以可用于检查指针是否为空

# 13. Visual Studio 的设置

制作一个项目模板，过程略了。

# 14. C++ 循环（for、while）

循环是当我们写代码时，需要多次执行同样的操作的时候用到的东西。

## 14.1 for 循环

```C++
for (int i = 0; i < 5; i++)
{
    Log("hello world");
}
```

- 如上例子，for 循环语句的三段申明：第一段在开始 for 循环时会运行一次；第二段是比较后产生的 bool 类型，它在 for 循环一次结束后进行评估；第三段在 for 循环的最后执行。

基于以上规则，我们可以将 for 循环改写成以下样式：

```C++
int i = 0;
	for ( ; i < 5; )
	{
		Log("hello world");
		i++;
	}
```

写成以下样式也是可以的，因为我们并没有改变程序的行为，只是改变了代码的位置。

```C++
int i = 0;
bool condition = true;
for ( ; condition; )
{
    Log("hello world");
    i++;
    if (!(i < 5))
        condition = false;
}
```

## 14.2 while 循环

while 循环与 for 循环类似，它只是没有开头的申明以及后面的语句，仅有条件语句。与此相应的 while 循环可写为：

```C++
int i = 0;
while (i < 5)
{
    Log("hello world");
    i++;
}
```

## 14.3 do while 循环

do while 循环不常用：do 关键字，然后执行循环体，然后 while 里写上循环判断条件。

```C++
int i = 0;
do 
{
    Log("hello world");
} while (i < 5);
```

**do while 循环至少执行一次循环体**，然后判断 while 里的条件，false 时则终止循环。

## 注

1. for 循环和 while 循环本质没有区别。
2. 约定俗称的情况是：如果你有一个已经存在的确定的条件，一般情况下用 while 循环。因为条件是不变的，即不需要在每次循环之后改变这个条件。不需要保持更新或初始化这个东西。
3. 当我们处理类似数组时，有固定的长度时，一般要使用 for 循环。
4. for(int i; ; ) 的 i 会在循环结束后自动释放，但 while 无法做到这一点，不可能在循环内部定义，也不可能在外面定义之后自动释放。

# 15. C++ 控制流语句

控制流语句与循环语句一起工作，主要的控制流语句有三个：**continue、break 和 return**。

- continue 只能在循环中使用，表示进入这个循环的下一个迭代，如果没有则循环结束。
- break 一般用于循环中，但也出现在 switch 语句中，break 意为跳出循环。
- return 会完全脱离你的函数。如果你在一个函数中，碰到了一个 return 关键字，你会退出这个函数。return 本身只适用于 void 函数，如果你的函数需要返回值，可由return 提供。

## continue

例如：

```C++
for ( int i = 0; i < 5; i++ )
{
    if (i % 2 == 0)
        continue;
    Log("hello world");
    std::cout << i << std::endl;
}

结果：
hello world
1
hello world
3
```

因为当 i = 0 或 2 或 4 时，i % 2 == 0，此时 continue 生效，执行下一次迭代，跳过了 Log 函数。

## break

```C++
for ( int i = 0; i < 5; i++ )
{
    if ((i + 1) % 2 == 0)
        break;
    Log("hello world");
    std::cout << i << std::endl;
}
结果：
hello world
0
```

当 i = 0 时，执行 Log 函数；当 i = 1 时，程序到达 break 语句，循环结束。

## return

当函数不是 void 类型时，程序申明要求必须返回值。**当函数运行到 return 时，程序会立即终止，整个函数结束**。

## 注

1. return 语句不一定在循环中使用。与 continue 和 break 不同，**return 可以使用在任何地方**。
2. 在任何情况下都不会被触发的代码被称为死代码。
3. 循环语句、if 语句和其他条件语句以及所有的控制流语句，构成了编程的基本逻辑。这些是唯一改变你的程序行为的东西。

# 16. C++ 指针

此处只讨论原始指针。（虽然我也不知道什么是原始指针，什么是智能指针）

- 计算机中的一切都存在于内存中，编程中最重要的就是内存：程序被载入到内存中，变量也存储在内存中。如果没有内存就什么都做不了。
- **指针** 对于管理和操纵内存非常重要。
- *指针是一个整数，一种存储内存地址的数字。* 一个指针只是一个地址，是一个保存内存地址的整数。类型不会改变指针的实质。

我们创建的每个变量都有一个内存地址，因为我们需要一个地方来存储这个变量。如果想知道这个变量的内存地址，可以通过 **&** 运算符来做到这一点。

- 在一个已经存在的变量前面加上一个 &，就能取出它的地址并赋值给新的变量。

```C++
int var = 8;
void* ptr = &var;//这个指针变量现在保存的是 var 变量的内存地址，vs 中显示为一个16进制的整数
```

## 解引用

当一个指针指向某个数据，当写入或读取这些数据，访问这些数据时，这就要靠逆向引用了（解引用）。方法是在指针变量前加上 **\***，如：*ptr。如：

```C++
int var = 8;
void* ptr = &var;
*ptr = 10;
```

- 运行会报错：这是因为这个指针是 void 类型的（无类型指针）。此时计算机无法将一个值写入到一个 void 指针，因为它不明白要将这个值存储为什么类型的数据，同样也不知道需要多少字节。所以指针需要指定类型。
- 在实际的指针中，并不知道内存多大，当我们创建数组时，它会跟踪内存大小。

## 堆内存

到目前为止，我们都是在**栈**中创建数据。但其实也可以在**堆**上创建一个变量。例如：`char* buffer = new char[8]`

- char 一个字节，设一个 buffer = new char，尺寸是 8。
- 此时真正要求的是 8 字节的内存，于是这里给我们分配了8个字节的内存，并返回一个指向那块内存开始的指针。

然后使用一个叫做 memset 的函数，它用我们指定的数据填充一个内存块，并且接受一个指针，这个指针将会是内存块开始的指针，还要写上数据大小（同上述的 8 个字节）。`memset(buffer, 0, 8）`

- 在这个例子中，我们使用了新的关键字 memset 来申请6了堆内存，当我们完成它后，我们也应该删除数据。
- 通过 delete 来实现，我们是使用数组来分配堆内存，所以我们使用 delete[] ,`delete[] buffer;`

**总结**：

1. 这个指针，我们分配 8  个 char，一个 char 是一个字节，这样我们就分配了 8 个字节。 
2. 我们用来存储数据的指针，指向了数据的开头。
3. 指针本身是变量，这些变量也存储在内存中，这意味着我们可以得到*双指针*或者*三指针*，意思是指向指针的指针。

```C++
char* buffer = new char[8];
memset(buffer, 0, 8);

char** ptr = &buffer;
```

- 此时可以发现 ptr 指向的地址空间里的数值与 buffer 所对应的地址相等。
- 可以看到 buffer 指针有 4 个字节的内存(因为是 32 位的应用程序)，在 32 位程序中，一个内存地址时 32 bit。
- 电脑的字节存储次序（元组排列顺序）实际上颠倒了，这与电脑的操作系统有关，常见的是小端序。

## 注

1. void 的意思是无类型。void 类型的指针意味着我们现在不关心我们的代码中这个指针是什么类型的。
2. `void* ptr = 0;` 此处将指针设置为 0 ，但 0 并不是一个有效的内存地址，我们不能从内存地址中读取或写入，应将其写为 `void* ptr = NULL;` 此处的 NULL 是一个 define（`#define NULL 0`）
3. C++11 以后的标准建议将其写为：`void* ptr = nullptr;` 。
4. 虽然指针类型不需要在乎，但它对于内存的操作很有用，类型可以帮助我们进行读写（由于编译器）。

# 17. C++ 引用

根本来说，引用通常只是指针的伪装。引用必须“引用”已经存在的变量，引用本身并不是新的变量，它们并不占用内存，也没有真正的存储空间。

- 之前我们学过：`int* b = & a;` 如果我们创建一个指针，我们可以在这里使用&运算符来实际获取现有变量的内存地址。
- 但这里不同，因为 & 符号实际上是类型的一部分，它实际上不在现有变量的旁边。
  

例如：

```C++
int a = 5;
int& ref = a;//&符号实际上是变量声明的一部分
```

- 现在所做的就是创造了一个叫做别名的东西，因为这个“ref”变量不是一个真正的变量，这只是一个引用。我们现在可以使用 ref 就像它是 a。
- 在这种情况下，我们的引用不是一个指针或者类似的东西，编译器不需要实际创建一个新变量

```C++
void Increment(int value)//整数变量递增
{
	value++;
}
int main()
{
	int a = 5;
	Increment(a);
	
	LOG(a);
	std::cin.get();
}
```

- 这里控制台会打印出 5，而不是 6，因为这里在将 a 作为参数传递进去时，只是通过值传递它。并没有把它作为一个指针或者一个引用或者类似的东西传递，它会拷贝这个 5，复制到函数中，复制会重新创建一个全新的变量 value。
- 因此我们需要通过 引用 来传递变量，这样它才会递增（因为我想影响的是这个变量）。

就像这样:

```C++
void Increment(int* value)//整数变量递增
{
	(*value)++;//这里要加逆向引用，如果不加的话，那就是对地址进行递增，而不是内存中的实际值。
	//这里如果不加括号的话，就是先加再逆向引用，所以要注意运算符优先级的问题。
}
int main()
{
	int a = 5;
	Increment(&a);
	
	LOG(a);
	std::cin.get();
}
```

- 这样我们就成功的通过引用将变量传递到一个函数中。但我们也可以选用一种更高效、简单、用更少的代码和更少的修饰语法的方法，利用**引用**。

就像这样：

```C++
void Increment(int& value)//整数变量递增
{
	value++;
}
int main()
{
	int a = 5;
	Increment(a);
	
	LOG(a);
	std::cin.get();
}
```

### 如何改变变量引用的东西

一旦声明了一个引用，你不能改变它引用的东西，例如：`int& ref = a; ref = b;` 这样是达咩达咩的。这样不会报错，但结果是 `a = 8`。

- 这也意味着当你声明一个引用时，你需要把它进行一个赋值（初始化）。因为它不是一个真正的变量，它必须引用一些东西。

如果我们想要改变上述例子中 ref 所引用的东西呢？

- 我们需要创建变量，可以首先设置它来指向 a，然后更改为指向 b。那就需要利用指针。就像这样：

```C++
int* ref = &a;
*ref = 2;
ref = &b;
*ref = 1;
结果是：a = 2;b = 1 
```

## 注

1. & 符号并不都是引用或者都是取地址，具体是啥取决于上下文。一般在类型的旁边是一个引用。
2. 要特别注意运算符的优先级。
3. 对于引用，没有什么是指针不能做的。指针比引用更强大，但能用引用代替的地方，引用更简洁。

# 18. C++ 类

简单来说，类只是对数据和功能组合在一起的一种方法。创建类（**class**），例如：

```C++
class Player
{
	int x, y;
	int speed;
};
```

注意右花括号后面有一个分号；这样我们就创建了一个全新的类叫Player。本质上它是一种类型。当我们使用它时，可以把它当做一种变量来创建。就像这样：`Player player;`

- 由 **类** 类型构成的变量称为对象，新的对象变量称为实例，所以刚才那句话所做的是实例化了一个 Player 对象，也可以说是为那个 Player 类型创建了一个新实例。
- 如果我们想设置这些变量，可以这样做：`player.x = 5;`，但编译时会报错：'*player 不能访问在类 Player 中声明的私有成员*'。这就涉及到类的可见性问题。

**可见性**

当你创建一个新 **类** 时，你可以选择指定类中的内容的可见性。默认情况下，一个类中的所有东西都是私有的。 *私有* 则意味着只有类中的函数才能访问这些变量。如果需要在 main 函数中访问这些变量，我们就需要将其设置为 **public** （公开）。public 意味着我们可以在类之外的任何地方访问这些变量。

就像这样：

```C++
class Player
{
public:
	int x, y;
	int speed;
};
```
现在写一个移动 player 的函数：
```C++
void Move(Player& player, int xa, int ya)//因为需要修改Player对象，因此通过引用传递
{
	player.x += xa * speed;
	player.y += ya * speed;
}
```

- 使用这个函数应该这样：`Move(player, 1, -1)`。

由于类中可以包含函数，所以我们也可以把这个函数写到类里，就像这样：

```C++
class Player
{
public:
	int x, y;
	int speed;
	void Move(int xa, int ya)//因为在Player里面，所以不需要传入对象
	{
		x += xa * speed;
		y += ya * speed;
	}
};
```

- 使用时：`player.Move(1, -1)`。这样我们就对代码进行了简化，而且每个 Player 对象都有自己的 Move 函数。当我们为指定的 Player 对象调用 Move 时，这个 Player 对象将会移动。它跟 Player 类外的 Move 函数没有区别，只是让我们的代码更干净了。

**类** 允许我们将变量分组到一个类型中，并为这些变量添加功能。

## 注

1. 类中可以包含函数，类中的函数被称为方法。
2. 类不会给你任何新的功能，可以用类搞定的事情，不用类也一样搞得定。

# 19. C++ 类与结构体对比

类（class）与结构体（struct）基本上没有区别，只有一个关于可见度的小区别。一个类中的成员，默认为 private。结构体中则默认为 public。

- struct 结构体在 C++ 中继续存在的唯一原因是因为它希望与 C 保持向后兼容性。因为 C 代码没有类，但是有结构体。而 C++ 编译器不知道什么是 struct。这里有一个简单的解决办法，就是使用 #define 来查找：`#define struct class` ，它所做的就是用 class 替换掉所有的 struct。
- 选用 struct 或 class 一般情况下基于个人习惯即可。

  cherno 在谈论 Plain old data (POD) 时，喜欢尽可能地使用 struct。这是一种只表示变量的结构，仅仅是一堆变量。数学中的 *向量类* 就是一个很好的例子。

  就像这样：

  ```c++
  struct Vec2
  {
  	float x, y;
  	void Add(const Vec& other)
  	{
  		x += other.x;
  		y += other.y;
  	}
  };
  ```
- 另外一种场景是继承，cherno 一般不会在 struct 中使用继承，如果需要有一个完整的类层次结构，或者某种继承层次结构，一般使用 **类**。因为继承是一种增加另一层次复杂性的东西。

# 20. 如何写一个 C++ 类

本节通过写一个简单的 log 类逐步写成一个更高级的类。这个 log 类是我们管理日志信息的一种方式。它提供向控制台写入文本的能力，并保持某种日志级别。下面让我们看看它是什么样子。

```C++
#include <iostream>

class Log
{
public://将日志级别用数字表示
	const int LogLevelError = 0;
	const int LogLevelWarning = 1;
	const int LogLevelInfo = 2;

private:
	int m_LogLevel = LogLevelInfo;//个人习惯加m_前缀用以表示成员变量

public:
	void SetLevel(int level)//引用类成员内部变量
	{
		m_LogLevel = level;//setlevel函数的作用就是为我们的成员变量赋值一个参数
	}

	void Error(const char* message)//这里为什么要用 char* 可以参考C++引用那一章的内容
	{
		if(m_LogLevel>=LogLevelError)
			std::cout << "[Error]：" << message << std::endl;
	}

	void Warn(const char* message)
	{
		if(m_LogLevel>=LogLevelWarning)
			std::cout << "[Warning]：" << message << std::endl;
	}

	void Info(const char* message)
	{
		if(m_LogLevel>=LogLevelInfo)
			std::cout << "[Info]：" << message << std::endl;
	}

};

int main()
{
	Log log;
	//设置一个日志级别
	//log.SetLevel(log.LogLevelWarning);//这意味着只有警告或更重要的信息才会被打印出来
	log.Warn("hello!");
	log.Error("hello!");
	log.Info("hello!");
	std::cin.get();
}
```

上面的代码虽然简单也很有逻辑，但并不简洁。接下来会使用一些不同的概念来改进这个类。

## 注

1. 创建一个类或者设计 API 时，一个很好的方法是通过研究它的使用情况。

# 21. C++ 中的静态（static）

static 关键字在 C++ 中有两个意思，这取决于上下文。其中之一是在类或结构体外部使用 static 关键字，另一种是在类或结构体内部使用 static。

- 类外面的 static，意味着你声明为 static 的符号，链接将只是在内部，这意味着它只能对你定义它的翻译单元可见。
- 然而，类或结构体内部的静态变量（static），意味着该变量实际上将与类的所有实例共享内存。这意味着该静态变量在你在类中创建的所有实例中，**静态变量只有一个实例**。（也就是说类中的静态变量不能实例化，但能共享）
- 类似的事情也适用于类中的静态方法。（类中的函数被称为方法）在类中，没有实例会传递给该方法。
- 静态变量或函数意味着，当需要将这些函数或变量与实际定义的符号链接时，链接器不会在这个翻译单元的作用域之外，寻找那个符号定义。

**本节我们只关注在类和结构体外部的静态。**

1. 我们在这里创建了一个静态变量，并将它设为 5。`static int s_Variable = 5;//它的意思是，这个变量只会在这个翻译单元内部链接。`（个人习惯，加s_前缀表示这是一个静态变量）
2. 然后到另一个 C++ 文件，也就是另一个翻译单元创建一个全局变量，并给它一个和之前静态变量一样的名字，设为 10：`int s_Variable = 10;`
3. 当我们尝试打印这个变量时：`std::cout << s_Variable << std::endl;`，结果为 10。
4. 回到 static.cpp 文件中，删除 static 关键字，编译代码，会得到一个链接错误：“fatal error LNK1169: 找到一个或多个多重定义的符号”，因为这个 s_Variable 变量已经在另一个翻译单元中定义了。也就是说我们不能有两个同名的全局变量。
5. 一种修改的方法是，修改这个变量的实际指向，让他指向的是这个 static.cpp 里的变量。可以这么做：去掉这里（main.cpp）的赋值，标识这个变量为 extern。就像这样：`extern int s_Variable;`。这意味着它会在外部翻译单元中寻找 s_Variable 变量。
6. 这被称为 external linkage 或 external linking。
7. 再次运行代码可以在控制台上得到 5。这是因为它引用了 static.cpp 里面的s_Variable 变量。
8. 如果加上 static 关键字就会报错：“error LNK2001: 无法解析的外部符号 "int s_Variable" ”。因为它在任何地方都找不到名称为 s_Variable 的整形变量，因为我们已经有效地标记了这个变量是私有的。这有点像在类中声明一个私有变量。其他的所有翻译单元都不能看到这个 s_Variable 变量。链接器在全局作用域下，将不会看到这个变量。
9. 对于函数也是同样的作用。

当你在类和结构体之外使用静态时，它只是意味着，当你声明静态函数或变量时，它只会在它被声明的 C++ 文件中被“看到”。

- 如果你想在头文件中声明一个静态变量，并将该头文件包含在两个不同的 C++ 文件中，那就是在两个翻译单元中都声明了相同的变量为静态变量，因为当你包含那个头文件时，它会复制所有内容并将其粘贴到 C++ 文件中，也就是将一个静态变量放到两个不同的翻译单元中。
- 一般情况，要让函数和变量标记为静态，除非你真的需要它们跨翻译单元链接。

## 注

1. C++ 中 **const 全局变量默认具有内部链接性**。
2. （没有 external 全局也只是局部）

# 22. C++ 类和结构体中的静态（static）

上一节讨论了类和结构体外的 static，这一节来讨论 static 在类和结构体中会怎样。在几乎所有面向对象的语言中，**静态在一个类中意味着特定的东西**。如果你把它和变量一起使用，这意味着在类的所有实例中，这个变量只有一个实例。

- 如果你创建一个名为 Entity 的类，然后不断创建 Entity 实例，你仍然只会得到那个变量的一个版本。这意味着，如果某个实例改变了这个静态变量，它会在所有实例中反映这个变化，因为静态变量的实例只有一个，尽管创建了一大堆类的实例。
- 因此，通过类实例来引用静态变量是没有意义的，因为这就像类的全局实例。静态方法也是一样，无法访问类的实例。
- 静态方法可以被调用，不需要通过类的实例。而在静态方法内部，你不能写 *引用* 到类实例的代码，因为你不能引用到类的实例。

```C++
#include <iostream>

struct Entity
{
	int x, y;

	void Print()
	{
		std::cout << x << "," << y << std::endl;
	}
};

int main()
{
	Entity e;
	e.x = 2;
	e.y = 3;

	Entity e1 = { 5,8 };

	e.Print();
	e1.Print();

	std::cin.get();
}

结果为：
2,3
5,8
```

- 但把 x 和 y 变成静态之后。 出现报错：C2078	初始值设定项太多。因为 x 和 y 不再是类成员。
- 写成 `Entity e1; e1.x = 5; e1.y = 8;` 出现报错：无法解析的外部命令。因为我们需要在某个地方定义那些静态变量。
- 因此我们可以写上 `int Entity::x` ，先写作用域 Entity，再写变量名 x。

就像这样：

```C++
#include <iostream>

struct Entity
{
	static int x, y;

	void Print()
	{
		std::cout << x << "," << y << std::endl;
	}
};

int Entity::x;
int Entity::y;

int main()
{
	Entity e;
	e.x = 2;
	e.y = 3;

	Entity e1;
	e1.x = 5;
	e1.y = 8;

	e.Print();
	e1.Print();

	std::cin.get();
}
结果为：
5,8
5,8
```

- 这是因为变量 x 和 y ，当我们让它们静态时，这两个变量在 Entity 的所有实例中只有一个实例，它们指向的是相同的内存。因此这里用引用是没有意义的，可以直接写成`Entity::x = 5; Entity::y = 8`。
- 这就像我们在名为 Entity 的命名空间中创建了两个变量，它们实际上并不属于类。
- 当你想要跨**类**使用变量时，只需要创建一个全局变量；或者使用一个静态全局变量（它在内部进行链接），不会在你的整个项目中是全局的。
- 那么为什么要在类中使用静态变量呢，如果你想要在所有的 Entity 实例之间共享数据，或者将它实际存储在 Entity 类中是有意义的，因为它与 Entity 有关。
- **静态方法不能访问非静态变量**，原因是静态方法没有类实例。
- 本质上，你在类中写的每一个方法，每个非静态方法，总是获得当前类的一个实例作为参数。这就是类的工作方式，它们通过隐藏参数发挥作用。静态方法不会得到那个隐藏参数。
- 静态方法与在类外部编写方法相同。

就像这样：

```C++
#include <iostream>

struct Entity
{
	int x, y;
};

static void Print(Entity e)
{
	std::cout << e.x << "," << e.y << std::endl;
}

int main()
{
	Entity e;
	e.x = 5;
	e.y = 8;
	Print(e);

	std::cin.get();
}
结果：
5,8
```

## 注

1. 静态成员函数只能调用静态的成员变量和成员函数。
2. 静态方法没得 this 指针。

# 23. C++ 中的局部静态（Local Static）

你也可以在局部作用域中使用 static 来声明一个变量，这和前两种有点不同。声明一个变量，我们需要考虑两种情况。就是变量的 **生存期** 和 **作用域**。

- 生存期指的是变量实际存在的时间。
- 作用域是指我们可以访问变量的范围。

静态局部变量允许我们声明一个变量，它的生存期基本相当于整个程序的生存期，然而它的作用范围被限制在这个函数内。

（但它其实和函数并没有什么关系，你可以在任何作用域中声明这个，并不仅仅局限在函数内部，可以在任何位置）

- 这就是为什么函数作用域中的 static 和类作用域中的 static 之间没有太大的区别。因为生存周期实际上是相同的。
- 唯一的区别是：在类作用域中，类中的任何东西都可以访问它（这个静态变量）；如果你在函数作用域中声明一个静态变量，那么它将是那个函数的局部变量。

这里有一个例子：首先创建一个函数并声明一个静态变量。

```C++
void cc()
{
	static int i = 0;
}
```

- 这意味着当我第一次调用函数时，这个变量将被初始化为 0，然后所有对函数的后续调用，实际上都不会创建一个全新的变量。

接下来检验一下：将函数中的变量打印出来，去掉 static，调用函数 5 次。

```C++
void cc()
{
	int i = 0;
	i++;
	std::cout << i << " ";
}
调用函数 5 次后结果为：1 1 1 1 1
```

- 这是因为我们每次都创建一个变量，并且令它等于 0，然后 + 1，提交给控制台。

如果加上 static 后，就是这样：

```C++
void cc()
{
	static int i = 0;
	i++;
	std::cout << i << " ";
}
调用函数 5 次后结果为：1 2 3 4 5

这就类似于：
int i = 0;//这里是静态的或非静态的都不重要，在这个例子中作用是一样的
void cc() //这种方法的问题是我可以在任意地方访问 i，如果不希望让每个人都能访问这个变量。
{		  //就可以在局部作用域下声明成 static。
	i++;
	std::cout << i << " ";
}
```

## 单例类

另一个例子是，如果你有一个单例类，单例类是只存在一个实例的类。如果我想创建这个单例类而不使用静态局部作用域，我就需要创建静态的单例实例，就像这样：

```C++
#include <iostream>

class Singleton
{
private:
	static Singleton* s_Instance;
public:
	static Singleton& Get() { return *s_Instance; }

	void Hello() { }
};

Singleton* Singleton::s_Instance = nullptr;

int main()
{
	Singleton::Get().Hello();
	
	std::cin.get();
}
```

这样代码量会很大，我们可以使用 local static 来对代码进行改进。

```C++
#include <iostream>

class Singleton
{
public:
	static Singleton& Get() 
	{
		static Singleton instance;//如果这里没有 static，那么这个单例就会在栈上创建，当代码运行到 }，函数作用域结束时，就会被销毁。
		return instance; //通过添加静态，将它的生存期延长到永久。这意味着第一次调用 Get，它实际上会构造一个单例实例，在接下来的时间，它只会返回这个已经存在的实例
	}

	void Hello() { }
};
int main()
{
	Singleton::Get().Hello();
	
	std::cin.get();
}
```

这是一个很好的例子，当你想这样用的时候，不一定非要用单例类，你可以通过替换掉初始化函数即可。

例如在程序中的某处调用一个静态初始化函数来创建所有对象，用它来简化代码。

# 24. C++ 枚举

枚举基本上就是一种数值集合，他们是给一个值命名的一种方法，它帮助我们将一组数值集合作为类型，而不仅仅是用整型作为类型，枚举数其实就是一个整数。

就像这样：

```C++
#include <iostream>

enum Example :char//指定类型
{
	A = 5, B, C//枚举值为整数，依次往后递增，默认从 0 开始，此处B=6，C=7
};
int main()
{
	Example value = B;
	std::cin.get();
}
```

例如在第 20 节，C++ 类中的例子，日志等级可以使用枚举。然后对后续代码进行改进。

```C++
#include <iostream>

class Log
{
public://将日志级别用数字表示
	enum Level//这个枚举 Level 本身不是一个命名空间，这叫做枚举类。
	{
		LevelError = 0, LevelWarning, LevelInfo
	};
private:
	Level m_LogLevel = LevelInfo;//个人习惯加m_前缀用以表示成员变量

public:
	void SetLevel(Level level)//引用类成员内部变量
	{
		m_LogLevel = level;//setlevel函数的作用就是为我们的成员变量赋值一个参数
	}

	void Error(const char* message)//这里为什么要用 char* 可以参考C++引用那一章的内容
	{
		if (m_LogLevel >= LevelError)
			std::cout << "[Error]：" << message << std::endl;
	}

	void Warn(const char* message)
	{
		if (m_LogLevel >= LevelWarning)
			std::cout << "[Warning]：" << message << std::endl;
	}

	void Info(const char* message)
	{
		if (m_LogLevel >= LevelInfo)
			std::cout << "[Info]：" << message << std::endl;
	}

};

int main()
{
	Log log;
	//设置一个日志级别
	//log.SetLevel(log.LogLevelWarning);//这意味着只有警告或更重要的信息才会被打印出来
	log.SetLevel(Log::LevelError);
	log.Warn("hello!");
	log.Error("hello!");
	log.Info("hello!");
	std::cin.get();
}
```

- 所以：如果你有一个数值集合，而你想用数字来表示它们。枚举就是你想要的。

## 注

1. 枚举默认为 32 位整型（ int ），枚举只能为整数。
2. 枚举本质上只是让我们的代码更干净。

# 25. C++ 构造函数

构造函数基本上是一种特殊类型的方法，它在每次实例化对象时运行。

接下来用例子解释：

```C++
#include <iostream>
class Entity
{
public:
	float X, Y;

	void log()
	{
		std::cout << X << "," << Y << std::endl;
	}
};

int main()
{
	Entity e;
	e.log();
	std::cin.get();
}
结果为：1.4013e-45,1.4013e-45
```

- 可以看到，虽然没有为 X 和 Y 指定值，但还是打印出了数字，这是因为当我们实例化 Entity，并为它分配内存时，我们实际上并没有初始化那个内存，而是得到了那个内存里原来的东西。

**构造函数** 

1. 构造函数就是在构造对象时，不需要操作，直接能够**自动运行**的初始化代码。

2. 构造函数是一种特殊类型的方法，这是一种每次你构造一个对象时都会调用的方法。

3. 它没有返回类型，并且它的名称必须与类的名称相同。就像这样：

   ```c++
   Entity()  // 其类名为Entity
   {
       X = 0;
       Y = 0;
   };
   ```

4. 如果不指定构造函数，你也会有一个默认构造函数，不过它的函数体里面是空的，没有为变量进行初始化。

**函数重载**

即有相同的函数（方法）名，但是有不同的参数的不同函数的版本。

- 如果在构造函数中加入参数，那么就需要在实例化对象时传入合适的参数。例如：

  ```c++
  Entity(float x, float y)//其类名为Entity，构造函数名应与类的名称相同
  {
  	X = x;
  	Y = y;
  }
  //实例化对象时应为
  Entity e(10.0f, 5.0f);
  ```

- **构造函数，如果不实例化对象，将不会运行**，所以如果你只使用一个类的静态方法，它不会运行。

也有一些方法可以删除构造函数，例如这个 Log 类，只有静态的日志方法。

```C++
class Log
{
public:
	static void write()
	{
		
	}
};

int main()

{
	Log::Write();//只想让别人这使用这个类
	Log l;//而不是这样创建实例
}
```

有两种不同的解决办法，我们可以通过设置 private 来隐藏构造函数。

```C++
class Log
{
	Log(){}
public:
	static void Write()
	{
		
	}
};

int main()

{
	Log::Write();
	Log l;//这里会得到一个错误，因为不能访问构造函数。如果将构造函数设置为 public 则此处不会出现报错
}
```

- 如果没有 private 的构造函数，显然是允许构造对象的。C++ 为我们提供了一个默认构造函数，但我们也可以自己写一个，例如：```Log() = delete;```,那么也不能这么调用 Log (```Log l;```)，因为默认构造函数实际上并不存在，已经被删掉了。报错信息为： error C2280: “Log::Log(void)”: 尝试引用已删除的函数

以上就是构造函数的内容，它是一个特殊的方法，在你创建类的实例时运行，它的主要用途是初始化该类。当你创建一个新的对象实例时，构造函数确保你初始化了所有的内存，做了所有你需要做的设置。

## 注

1. 像 Java 等语言，数据基本类型，比如 int 和 float，会自动初始化为 0。但 C++ 并非如此，C++ 必须手动初始化所有基本类型。
2. 当使用 new 关键字并创建一个对象实例时，它也会调用构造函数。

# 26. C++ 析构函数

构造函数是你创建一个新的实例对象时运行，而析构函数是在销毁对象时运行。任何时候，一个对象要被销毁时，析构函数将会被调用。

- 构造函数通常是设置变量或者做任何你需要的初始化，而析构函数则是你卸载变量等东西，并清理你使用过的内存。
- 析构函数同时适用于栈和堆分配的对象，如果你使用 new 分配一个对象，当你调用 delete 时，析构函数会被调用。
- 而如果只是一个栈对象，当作用域结束时，栈对象将被删除，这时，析构函数也会被调用。

析构函数与构造函数在声明与定义时的唯一区别，就是放在析构函数前面的波浪号。就像这样：

```C++
#include <iostream>
class Entity
{
public:
	float X, Y;
	Entity()  // 构造函数
	{
		X = 0.0f;
		Y = 0.0f;
		std::cout << "Created Entity!" << std::endl;
	}

	~Entity()  // 析构函数：~后面跟着类名
	{
		std::cout << "Destroyed Entity!" << std::endl;
	}
	void log()
	{
		std::cout << X << "," << Y << std::endl;
	}
};

void Function()
{
	Entity e;
	e.log();

}
int main()
{
	/*
	Entity e;	// 因为这是栈分配的，只有当主函数退出时，析构函数才会被调用
	e.log();	// 所以析构函数里的提示信息我们实际上不会看到，因为程序会在那之后立即结束，因此加入一个函数 function 执行 Entity 的相关操作。
	*/
	Function();
	std::cin.get();
}
结果为：
Created Entity!
0,0
Destroyed Entity!
//可以看出构造函数和析构函数时自动运行的。设置断点，单步执行可以看到更清楚的步骤：实例化时构造函数运行，作用域结束时析构函数运行。
//因为它的对象是在栈上创建的，当超出作用域时，它会被自动销毁
```

这就是析构函数的本质，它只是一个特殊函数或特殊方法，在对象被销毁时调用。

1. 如果在构造函数中调用了特定的初始化代码，你可能想要在析构函数中，卸载或销毁所有这些东西。
2. 如果你不这么做，你可能会造成内存泄漏。例如：在堆上分配的对象，如果你在堆上手动分配了任何类型的内存，那么你就需要手动清理。如果在 Entity 类使用中或者构造中分配了内存，你可能会要在析构函数中删除它们（内存）。 因为当析构函数调用时，那个 Entity 实例对象消失了。
3. 你也可以手动调用析构函数，但基本没有人这么使用。

# 27. C++ 继承

面向对象编程是一个巨大的编程范式，类之间的继承是它的一个基本方面，是我们可以实际利用的最强大的特性之一。

**继承**允许我们之间有一个相互关联的类的层次结构，它允许我们有一个包含公共功能的基类，然后它允许我们从那个（基）类中分离出来，从最初的父类中创建子类。

这些类、继承等如此有用的主要原因是它可以帮助我们避免代码重复，我们不需要一遍遍的重复，我们可以把类之间的所有公共功能放在一个父类中。，然后从基类（父类）中创建（派生）一些类，稍微修改。继承给我们提供了这样一种方式。

```C++
class Entity
{
public:
	float X, Y;

	void Move(float xa,float ya)
	{
		X += xa;
		Y += ya;
	}
};

class Player : public Entity  // 在类型声明后写一个冒号，然后指明继承的对象 
{							  // 这里发生了一些变化，Player 类现在不仅拥有Player 类型，也有Entity 类型
public:	
	const char* Name;
	// 这里有相当多的代码只是被复制粘贴，因此我们可以利用继承：扩展 Entity 类，来创建一个名为 Player 的新类型，然后让它存储新数据或基类中不存在的函数
	// 继承后，Player 现在拥有 Entity 拥有的所有东西。
	// float X, Y;

	// void Move(float xa, float ya)
	// {
	// 	X += xa;
	// 	Y += ya;
	// }
	void PrintName()
	{
		std::cout << Name << std::endl;
	}
	// 这个Player实际上是一个Entity,这意味着它并不是一个整体，而是需要跟Entity 结合着看。任何在Entity 类中不是私有的东西，实际上都可以被Player访问
};
```

我们可以在 Player 中访问 Entity 中的内容，就像这样：

```C++
int main()
{
	Player player;
	player.Move(5,5);
	player.X = 2;
	std::cin.get();
}
```

- 其他我们可以应用的概念是叫做"**多态**"。基本上，多态是一个单一类型，但有多个类型的意思。
- 这里的 Player 不仅仅是一个 Player 类型，也是一个 Entity 类型。这意味着我们可以在任何我们想要使用 Entity 的地方使用 Player。player 是 Entity 的超集。
- 我们可以对这些多态特征做很多事情，比如可以改变父类的行为。例如，重写一个方法，并给它新的代码来代替它（父类方法）运行。
- 继承是我们一直在使用的一种方式，是我们扩展现有类并为基类提供新功能的一种方式，这是面向对象编程中最重要的东西之一。

## 注

1. 类型在 C++ 中是相当复杂的主题，一方面它们实际上并不存在，另一方面它们又很容易搞事。特别是如果你有特定的运行标记激活的话。
2. 当你创建一个子类时，它将包含你的父类所包含的一切。通过比较 Entity 和 Player 的 size 可以看出来。
3. 这些类的大小和内存实际上可以变化，如果我们开始重写函数和player类，那么我们就需要维护一个 V表（虚函数表），也就是要额外的内存。

# 28. C++ 虚函数(这一节很难，多看几遍)

虚函数对于整个面向对象概念都非常重要。虚函数允许我们在子类中重写方法。

例如：假设我们有两个类 A和B，B是A 派生出来的（即B是A的子类）。如果我们在A类中创建一个方法，标记为 virtual，我们可以在B类中重写这个方法。

```C++
#include <iostream>
#include <string>

class Entity
{
public:	
	std::string GetName() { return "Entity"; }
};

class Player : public Entity
{
private:
	std::string m_Name;
public:
	Player(const std::string& name) : m_Name(name){}
	std::string GetName() { return m_Name; }

};

int main()
{
	Entity* e = new Entity();
	std::cout << e->GetName() << std::endl;//打印Entity里面的GetName()
	Player* p = new Player("Cherno");
	std::cout << p->GetName() << std::endl;//打印Player里面的GetName()
	
	//For example:创建一个名为entity的变量，它会被赋值为 p,
	Entity* entity = p；//这个 p 是指向 Player 的指针，因此是一个 Player,但我把它指向 Entity。
	std::cout << entity->GetName() << std::endl;//如果我打印这些，得到的结果是：Entity。然而我们希望得到的是Player,因为即使我们指的是这个Entity,但它实际上是一个Player。(p是Player类的一个实例)
	std::cin.get();
}
结果是：
Entity
Cherno
```

下面这个例子更清晰：

```C++
#include <iostream>
#include <string>

class Entity
{
public:	
	std::string GetName() { return "Entity"; }
};

class Player : public Entity
{
private:
	std::string m_Name;
public:
	Player(const std::string& name) : m_Name(name){}
	std::string GetName() { return m_Name; }  // 覆写函数写在这里，大括号前面

};

void PrintName(Entity* entity)  // 现在我们有一个函数，它可以接受任何Entity参数，当我们试图将 p 传递给参数时，因为 p 是一个 Entity( p 是Player的实例，而 Player 是 Entity)
// 这意味着，当我们调用GetName函数时，如果是在Entity里面，那么它会从Entity里面找这个函数；但我们希望传递的entity实际上是Player
{
	std::cout << entity->GetName() << std::endl;
}

int main()
{
	Entity* e = new Entity();
	PrintName(e);
	Player* p = new Player("Cherno");
	PrintName(p);  // 调用 GetName 方法打印结果为Entity

	std::cin.get();
}
结果是：
Entity
Entity
```

- 发生这种情况的原因是，在我们通常声明函数时，我们的方法通常在**类内部**（起作用）。然后当要调用方法的时候，会调用属于该类型的方法。
- 这个 PrintName 函数，它的参数是 ntity。这意味着，当我们调用 GetName 函数时，如果是在 Entity 里面，那么它会从 Entity 类中找这个叫做 GetName 的函数。

但我们希望 C++ 能够明白，我在这里传递的 Entity 实际上是 Player。

1. 这就是虚函数出现的地方，虚函数引入了一种叫做 **Dynamic Dispatch（动态联编）**的东西，它通常通过 V 表（虚函数表）来实现编译。

2. V 表就是一个表，它包含基类中所有虚函数的映射，这样我们就可以在它运行时，将它们映射到正确的覆写（override）函数。

3. 如果你想覆写一个函数，必须将基类中的**基函数**标记为**虚函数**。

4. 那么我在 GetName 函数前面加一个 virtual，就像这样：`virtual std::string GetName() { return "Entity"; }`

   这就可以告诉编译器：生成V表吧，为这个函数。这样如果它被重写了，你就可以指向正确的函数。

   有了这些变化之后，上面的代码运行结果为：`Entity Cherno`，这样我们就得到了正确的结果。

## override

C++ 11 引入的，将覆写函数标记为关键字 **override **。写在指定的地方，就像这样：`std::string GetName() override { return m_Name; }`，但这不是必需的，但你最好这样做。有以下原因：

1. 这让它更具可读性，让我们知道这实际上是一个覆写的函数。
2. 它还可以帮助我们，预防 bug 的发生。（覆写的函数名如果输错，会提示；或者我们试图覆写一个 非虚函数，也会给出错误提示）

这些就是虚函数的本质了，虚函数并不是无开销的。实际上，有两种与虚函数相关的运行成本。

1. 我们需要额外的内存来存储 V 表，这样我们就可以分配到正确的函数。包括基类中要有一个**成员指针**，指向 V 表。
2. 其次，每次我们调用函数时，我们需要遍历这个表，来确定要映射哪个函数，这是额外的性能损失。

## 注

1. 这一P看了好几遍，我的理解是子类覆写了父类的一个方法，但是我们在调用的时候，本来是想要调用子类的方法，但是程序却调用父类的了。因为我们写了一个下面的方法

   ```c++
   void PrintName(Entity* entity)
   {
       std::cout << entity->GetName << std::endl;
   }
   ```

   然后程序就傻傻的去Entity里面找GetName这个方法，一找就找到了，就用他了。

   但是我们的Player是Entity的子类，我们在下面main函数中使用了`Player* p = new Player("Cherno");`是想用Player里面的GetName，而且写的也很明白。接下来我们写上PrintName(p)，这个语句却调用了父类里面的GetName，没有用子类的。所以我们需要在你想要覆写的父类方法前面加上virtual，这样程序就会生成一个表，表里面记录了你哪些子类覆写了这个方法，当你调用的时候他会在表里找。但找的过程要消耗资源。

2. 虚函数是解决继承里赋值兼容所导致的问题，多态的设计方法可以保证在赋值兼容的前提下，基类、派生类分别以不同的方式来响应相同的消息。

3. `Player(const std::string& name) : m_Name(name) {}`
    这一句代码是什么意思阿？ 有没有大佬解读一下
    答：构造函数初始化列表

4. 由于虚函数开销很大，如果在一些嵌入式平台上性能不足，那么应该尽量避免使用虚函数。

# 29. C++ 接口（纯虚函数）

本节学习一种特殊类型的虚函数，叫做纯虚函数。

C++ 纯虚函数本质上与其他语言（如 Java 或 C#）中的抽象方法或接口相同。基本上，纯虚函数允许我们在基类中定义一个没有实现的函数，然后强制子类去实现该函数。

在之前的例子中，Entity 类中有一个虚函数 GetName，然后我们重写了那个函数在 Player 类中。在基类中这个GetName函数有函数体，意味着在某个类中重写它只是一个可选项（即也可以选择不重写）即便我们不重写它，我们仍然可以调用Player.GetName，然后返回Entity字符串。但有些时候提供这些实现是没有意义的。

实际上，我们可能想要强制子类，为特定的函数提供自己的定义。**在面向对象编程中，创建一个类，只由未实现的方法组成，然后强制子类去实际实现它们，这非常常见。**这通常被称为**接口**。

因此，**类中的接口只包含未实现的方法，作为模板**。由于这个接口类实际上并不包含方法实现，我们实际上不可能实例化那个类。（这也是为什么构造函数不能设置成纯虚函数）

```C++
class Entity
{
public:	
	virtual std::string GetName() = 0;//这里仍然定义成 virtual 虚函数，变成纯虚函数之后，我们就不再具有实例化 Entity 类的能力，
};
```

- 这里仍然定义成 virtual 虚函数，但 = 0 本质上使它成为一个纯虚函数，这意味着它必须在一个子类中实现，如果你想实例化这个子类的话。

- 所以：你只能在实现了所有这些纯虚函数之后，才能够实例化。或者在更上层次的类实现它。比如，Player 是另一个类（Entity 的子类）的子类，而这个类实现了 GetName 函数，那也是可以的。

## 接口

编写一个函数来打印这些类的类名

```C++
void Print(Printable  obj)//这里我们需要有一个类型，来保证我们有这个GetClassName 函数，这就是“接口”
{						  //把它叫做Printable,然后设置它	
	std::cout << obj->GetClassName()->std::endl;
}
```

创建一个新类，叫 Printable，现在所有类都需要实现这个 GetClassName 函数了。如果不是，你就不能实例化这个类。

```C++
#include <iostream>
#include <string>

class Printable//虽然把它叫做接口interface，但它只是一个类，因为它不过就是有一个纯虚函数而已
{
public:
	virtual std::string GetClassName() = 0; //返回值为字符串的纯虚函数
};

class Entity : public Printable
{
public:	
	virtual std::string GetName() { return "Entity"; }
	//如果我们写上下面这一行代码。首先，我们无法实例化的问题已经解决了，然而注意到还没有为Player提供一个覆写函数
	std::string GetClassName() override { return "Entity"; }
};

class Player : public Entity , Printable //指定一个接口
{
private:
	std::string m_Name;
public:
	Player(const std::string& name) : m_Name(name){}
	std::string GetName() { return m_Name; }

};

void PrintName(Entity* entity)
{
	std::cout << entity->GetName() << std::endl;
}
//编写一个函数来打印这些类的类名
void Print(Printable* obj)//这里我们需要有一个类型，来保证我们有这个GetClassName 函数，这就是“接口”
{
	std::cout << obj->GetClassName() << std::endl;
}
int main()
{
	Entity* e = new Entity();
	//PrintName(e);
	Player* p = new Player("Cherno");
	//PrintName(p);

	Print(e);
	Print(p);

	std::cin.get();
}
报错：C2259	“Player”: 无法实例化抽象类
也可能出现打印两次Entity的情况，因为没有在Player中提供定义	
如果在 Player 中添加一段代码：
std::string GetClassName() override { return "Player"; }
就能得到正确的类名：
Entity
Player
```

- 所有这些都来自于一个 Print 函数，这个函数接受 Printable 作为参数，它并不关心具体是什么类，就像这样：

```C++
class A : public Printable //我们创造了一个新的类，并且实现了Printable 这个接口，即实现了这个函数
{
public:
	std::string GetClassName() override { return "A"; }
};
//现在就可以调用打印了
Print(new A());//注意这句代码会造成内存泄漏
```

- 可以看到打印了 A，因为这是一个 Printable，它保证了 A 类有这个 GetClassName 函数。这就是工作原理，因为它知道任何 Printable 的东西，都有一个 GetClassName 函数去调用。如果你不实现这个函数，这样你就不能实例化这个类

## 注

1. **纯虚函数必须被实现，才能创建这个类的实例。**
2. 实际上，在其他语言中有 interface（接口）关键字而不是叫 class，但 C++ 没有。接口只是 C++ 的类而已
3. 纯虚函数（接口）确保类都有一个特定的方法，那么可以将这个类（抽象基类）作为参数（类型）放入一个通用的函数中，然后就可以调用这个方法或者做其他事情。

# 30. C++ 可见性

可见性是一个属于面向对象编程的概念，它指的是类的某些成员或方法实际上有多可见（可看见、可调用、可使用），可见性是对程序实际运行方式完全没有影响的东西，对程序的性能等东西也没有影响。它只是帮助你更好的组织代码。

C++ 中有三个基础的可见性修饰符：public、private 和 protect，在其他语言中有别的修饰符。可以自己换一下修饰符，看看在子类或其他函数里调用它有什么变化。

```C++
// private 意味着只有*当前这个类可以访问这些内容
#include <iostream>
#include <string>

class Entity
{
protected:
	int X, Y;

	void Print () {}
public:
	Entity()
	{
		X = 0;
		Print();
	}
};

class Player : public Entity
{
public:
	Player()
	{
		X = 2;
		Print();
	}
};

int main()
{
	Entity e;
	e.X = 2;
	e.Print();

	std::cin.get();
}
```

1. 这里的 only 要给个星号*，因为在 C++ 中有个叫 friend 的东西。friend 是 C++ 关键字，它可以让类或者函数成为类（Entity）的朋友（**友元**），实际上可以从类中访问私有成员。
2. 只有 Entity 类和它的**友元**才能访问私有变量或函数。
3. protected 比 private 更可见，比 public 更不可见。

protected 意思是这个 Entity 类和层次结构中的所有子类，也可以访问这些符号。

## 为什么要设置可见性

可见性是让代码更加容易维护，容易理解，不管是阅读代码还是扩展代码。不仅不会影响性能，也不会产生完全不同的代码。

为了让使用者知道哪些代码是可以被调用的，哪些是不希望被外部函数访问的。

代码是个错综复杂的东西，通过明确**可见性**，我们可以确保人们不会调用他们不应该调用的代码，并可能破坏某些东西。

基于可见性，你可能会看到，你想要的访问和利用类的方式。

# 31. C++ 数组

数组基本上是元素的集合，按特定的顺序排列的一堆东西。C++ 数组就是表示一堆的变量组成的集合，一般是一行相同类型的变量。

```C++
int main()
{
	int example[5];  // []里的5是想要创建的数组的元素个数，前面的int指明这是一个整数数组。
	example[0] = 5;  // 这个数组后面的[]里面是数组的index（索引），索引是我在数组中指向的那一个变量或者元素
	example[4] = 4;

	std::cout << example[0] << std::endl;  // 如果想打印一个元素，只需要指明索引即可
	std::cout << example << std::endl;  // 如果你想打印这个数组，你需要打印这个数组的地址。因为这实际上是一个指针类型
	
	std::cin.get();
}
```

- C++ 的数组索引下标是从 0 开始的，一些语言，比如 lua 语言是从 1 开始的。记住，C++ 中下标 0 代表第一个元素。本例子中共有5个元素，因此最后一个元素的索引为4。
- 当你索引数组中的元素是，你会得到底层的数据类型，在本例中是一个整形。
- 如果我试图访问一个索引，不在数组里面。例如试图访问-1或5，我们称之为 Memory access violation（内存访问违规），在 debug 模式下，你会得到一个程序崩溃的错误消息，来帮助你调试那些问题。然而在 release 模式下，你应该不会得到报错信息。这意味着你已经写入了不属于你的内存。

数组与 for 循环经常在一起，因为 for 循环可以通过索引来遍历，在一个特定的范围内。所以我们如果想设置 example 数组中的每一个值，可以通过 for 循环来实现：

```C++
int example[5];
for (int i = 0; i < 5; i++)//也可以写成 <=4，但最好不要，因为这涉及到性能问题。所以这里几乎总是写成<5，而不是<=4。
	example[i] = 2;//通过 example[i] 来访问特定索引时，它实际做的是对这个内存取了一个偏移值
```

- example 实际上是它自己的内存地址，因为 example 是一个整形指针。
- 数组最重要的一点是，它们连续的存储数据。所以打开内存空间可以看到，它们的数据放在了一排。  02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00 ，一共有5个2，每个占据4字节，因为它们是整形int。
- 数组实际上只是一个指针，一个整形指针, 因此定义一个整形指针，并给它赋值为 example，就像这样：`int* ptr = example;` 这样也是完全不会出错的。

```C++
int main()
{
	int example[5];
	int* ptr = example;

	for (int i = 0; i < 5; i++)
		example[i] = 2;
	example[2] = 5;
	//访问2号元素，即写入从指针开始的8个字节的偏移量（地址），在指针算数上是 ptr+2，因为是向前2个元素
	*(ptr + 2) = 6;//这里的 +2 并不是指字节，因为这个指针是 int 类型的
	
	std::cin.get();
}
```

- 断点处可以看到：example[2] = 5; 后 
  02 00 00 00 02 00 00 00 **05 00 00 00** 02 00 00 00 02 00 00 00
  *(ptr + 2) = 6; 后
  02 00 00 00 02 00 00 00 **06 00 00 00** 02 00 00 00 02 00 00 00
- 通过指针来计算偏移量时，跟指针的类型有关，这个例子中是一个 int 指针，所以将会增加 2*4 的偏移量（一个 int 一般是 4 个字节）。所以这里也可以写为`*(int*)((char*)ptr + 8) = 6;`（char 是一个字节）。这样虽然奇怪，但是可行。

## 31.1 堆上（heap）数组

我们可以通过 new 关键字来创建一个对象（实例）。同样我们也可以通过使用 new 来创建一个数组。就像这样：

```C++
int main()
{
	int example[5];
	int* another = new int[5];//方括号里面是数组大小
	
	std::cin.get();
}
```

- 这两行代码是一个意思，然而，生存期是不同的。`int example[5];` 是在**栈**上创建的，当我们到达最后的花括号时，它会被销毁，因为跳出了作用域范围。
- 如果是**堆**上创建的话，直到我们程序把它销毁之前，它都是处于活动范围的。所以你需要用 delete 关键字来删除。`delete[] another;`

```C++
int main()
{
	int example[5];
	for (int i = 0; i < 5; i++)
		example[i] = 2;

	int* another = new int[5];//方括号里面是数组大小
	for (int i = 0; i < 5; i++)
		another[i] = 2;
	//因为这是一个数组，我们在这里使用数组的操作符[]来分配（内存），所以我们使用了带方括号的 new 关键词，删除时也需要这样。
	delete[] another;

	std::cin.get();
}
```

- 执行赋值操作后查看内存发现结果是一样的。

**Question?**：为什么要动态的用 new 来分配，而不是在栈上创建呢？

- 最大的原因是生存期，用 new 来分配的内存将一直存在，直到被删除。
- 如果有一个函数返回一个数组，你必须使用一个 new 关键字来分配它，除非你传入一个数组的地址参数。如果你想返回一个数组，这个数组是在函数中创建的，你也需要使用 new 关键字。

## 31.2 间接寻址

此时需要考虑 **间接寻址**：因为我们实际上有一个指针，那个指针会指向另一个内存块，这个内存块保存了我们实际的数组。这将会产生某种内存碎片（memory fragmentation）、缓存丢失（cache miss）以及一些复杂的东西。

举个例子：

```C++
#include <iostream>
#include <string>

class Entity
{
public:
	int example[5];
	//使用 new 在堆上创建
	//int* example = new int[5];
	Entity()
	{
		for (int i = 0; i < 5; i++)
			example[i] = 2;
	}
};
int main()
{
	Entity e;

	std::cin.get();
}
```

- 进入 Entity 对象 e 的内存地址（设置断点执行后在内存窗口查询&e），可以看到：02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00；Entity 的内存地址上，实际上就是一行，包含了数组的所有 2。
- 但如果使用 new 关键字在堆上创建，运行后进入内存地址。并没有看到 2，但有一个地址a8 c7 a5 00（int类型，所以4个字节），这个地址就是这个指针。
- 现在复制这个地址查询（转换一下字节序为：00a5c7a8）后可以得到:02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00 02 00 00 00。这样就能拿到实际的数据了。**这就是所谓的 memory indirection（内存间接寻址）**，我们实际得到的 e 的内存地址，是我们数组的实际内存地址，这意味着当我们想要访问这个数组时，首先需要找到 Entity，接着找到数组。
- 因此，只要有可能，应该在**栈**上创建数组来避免这种情况。因为像这样在内存中跳跃肯定会影响性能。

## 13.3 C++ 11 里面的数组

在 C++ 11 中，我们有标准数组 **std::array**，这是一个在 C++11 中内置的数据结构，很多人喜欢用它来代替上面所展示的原始数组，因为它有很多优点。比如边界检查、记录数组大小（原始数组的大小实际上不能被计算出的）。

如果你使用C++11，你可以写：

```C++
# include <array>
std::array<int, 5> another;
for (int i = 0; i < another.size(); i++)
	another[i] = 2;
```

- 这是一种简单的处理办法，但它有别的开销，它可以做边界检查，也实际上保持了一个整数的size(数组大小)。所以会有一些开销，但很值得。

## 13.4 原始数组大小

实际上没有办法计算出原始数组的大小，在许多其它的语言中，可以写`example->size()`，但在 C++ 中，你不能这么做，你无法知道数组的大小。

1. 但当你删除这个数组时，编译器却需要知道实际上需要释放多少内存。因此有一种方法是，通过编译器相关的东西。它可能有时存储在数组的一个负索引里面，这取决于很多因素。这很不值得信任。因此，**你永远不应该在数组内存中，访问数组的大小**，这很危险。
2. 如果你在**栈**上分配一个数组 `int a[5];`，你不知道它的实际大小。因为这是**栈的地址加上偏移量**，所以如果你写 `sizeof(a);`，你实际得到的是数组占了多少字节。本例中 int 是 4 个字节，5 个数组元素，因此 sizeof(a) 给你的值是 20个字节。因此元素的计数可以由这段代码给出：`int count = sizeof(a) / sizeof(int);//结果为 5，也就是已经分配的元素的数量`。但如果是`int count = sizeof(example) / sizeof(int);//sizeof(example)=4，因此结果为1`（因为指针是 int 类型的），这明显错误。所以如果你要使用这种方法，你必须在**栈**中分配数组。
3. 但最好不要相信这个方法。当你把它放在函数里面或者其他什么东西里，它一旦变成了 int 指针，就完蛋了。很容易造成错误。所以你应该**自己维护自己数组的大小**。

一种写这种代码的方式是:

```C++
class Entity
{
public:
	/*const int size = 5;
	//这样是达咩达咩的，当你在栈中为数组申请内存时，它必须是一个编译时就需要知道的常量。这里需要先打个*，因为这是C++（嘻嘻）
	int example[size];
	所以你必须要标记为static
	*/
	static constexpr int examplesize = 5;//这里还可以使用常量表达式constexpr，在类中的常量表达式必须是静态的，直接使用static const int size = 5;
	int example[examplesize];

	Entity()
	{
		for (int i = 0; i < examplesize; i++)
			example[i] = 2;
	}

};
```

## 注

1. 你要注意确保，你总是在数组的边界内写东西，因为如果你没有，它会导致一些很难调试的问题。因为你刚刚修改了内存，这些内存不是这个数组的一部分，而有可能是源代码中，另一个变量的一部分。你在没有意识到的情况下，将代码中的其他变量改掉了。所以要确保你设置了安全检查，确保你写的东西没有超出界限。
2. C++ 中常用前闭后开区间，迭代器也是这样设计的。
3. **一般的计算机都是小端的**。
4. 其实数组的定义是在这门语言中相同类型的一个数据的集合。
5. 稍微补充一下 (本人也是菜鸟，可能有误，欢迎纠错) cherno 好像没有明确说明 (14分左右说明不够清晰) 数组名并不是指针，只是可以隐式转换为指针，这可以解释 sizeof (数组名) 为什么得到的是数组的字节长度，基于这个原因，cherno才会说不能相信用sizeof求长度的方法。

   在静态创建数组作用域中，sizeof (数组名) ，其中的数组名代表的整个数组的大小，然而在将数组名作为指针传参给其他方法是，代表的只是一个指针，所以在非静态创建数组作用域中，（传过去的）数组名是指针，用sizeof 求得只是一个指针的大小，所以在静态创建数组作用域中需要对数组大小进行维护。

# 32. C++ 字符串

字符串与数组紧密相连，字符串本质是一个接一个字符的一组字符（字母、数字、符号）。对于我们来说，这是一种能够表示和处理文本的方法。

在 C++ 中，有一种数据类型叫做 char。

## 32.1 char

1. 这是**一个字节**的内存，它很有用，他能把指针转换成 char 型指针，所以你可以用字节来做指针运算。
2. 它对于分配内存缓冲区也很有用，如果你想分配 1k 的内存，你可以分配 1024 个 char。
3. 他对字符串和文本也很有用，因为 C++ 对待字符的默认方式是通过 ASCII 字符进行编码。但是我们在 C++ 中处理字符是一个字符一个字节的。

在 C++ 基础语言中，不使用任何库，只是原始数据类型，char 是一个字节。这就是为什么当你在 C++ 中使用一个字符串，不是 2 个字节的宽字符串。

普通的字符串使用普通的字符，例如英语。如果是中文就需要使用不同的字符编码（2个字节）。虽然有很多人忽视它们，但其实文本和语言是一个庞大的、大规模的、复杂的问题。

## 32.2 字符串在 C++ 中如何工作

字符即 char 是一种数据类型，而**字符串实际上是字符数组**，而数组又是一组元素的集合。所以，一组字符组成了字符串或文本。

```C++
int main()
{
	const char* name = "cherno";//声明字符串，name 是字符串名。
	//const 关键字，意味着你不能再改变它的内容。

	std::cin.get();
}
```

- 这是 C 语言风格定义字符串的方式。因为我们 C++ 有一个库，使得字符串操作变得简单。你可以不加 const，但人们这样做的原因是，不想去改变这些字符串的值，因为**字符串是不可变的**。
- 意思是说，你不能扩展字符串并使他变大，因为它是一个固定分配的内存块。
- 如果你需要一个更大的字符串，它需要执行一个全新的分配并删除旧的字符串。
- 这里的 char* 并不意味着它是在堆上分配的，你不能通过 delete 来删除这些东西。

下面看一下**字符串在内存里**是什么样子的。

![32](./img/32.PNG)

- 内存视图的右边是 ASCII 码表示，左边都是单独的字节。
- c 的 ASCII 编码就是 63。6 个字节之后是一个被设为 0 的字节，这被称为**空终止字符**，这样我们就知道那是字符串结束的地方。
- 字符串从指针的内存地址开始，然后继续下去，直到它碰到 0。

```C++
char name2[6] = { 'C','h','e','r','n','o' };//C++ 的字符是通过单引号，而双引号“”默认是 char*，不是字符串。
	//这是一个数组包含 6 个字符，不是字符串，没有空终止符，可以在后面加一个0或者'\0'，它代表 null。{ 'C','h','e','r','n','o', 0}

std::cout << name2 << std::endl;
//这里与视频中的不同。VS2019中的字符串后面是有空终止符的。打印结果也是正常的。
```

- 每当我们在调试模式下分配数组，C 标准库或者 C++ 标准库实际上会插入栈守卫之类的东西，这样我们就知道是不是在分配内存之外了。
- 这就是字符串，它是字符的集合。

## 32.3 如何在 C++ 中使用字符串

在 C++ 的标准库中有一个名为 String 的类，实际上有一个 baseString 类，它是一个模板类。而 std::string 基本上是 baseString 类的模板版本，模板参数是 char，这叫模板特化，就是将 baseString 模板类中的模板参数设为 char，意思是char 是每个字符背后的实际类型。有一些特殊的原因暂时先不讨论。

**在 C++ 中使用的字符串，你应该用 std::string**，它只是一个 char 数组和一些用来操作它们的一些函数。

1. 首先：`#include <string>`，在 iostream 里面其实已经有了 string 的定义了，所以如果已经有了 iostream 其实打印到控制台是其实不需要这个 string 的。
2. string 有一个构造函数，它接受 char* 或 const char* 参数（当你定义字符串时，用双引号引起来的一个单词或者多个单词在 C++ 中是 const char 数组，而不是 char 数组。）当你需要完全操纵字符串的时候是通过 char* 的隐式转换做到的。
3. string 中有很多方便好用的对字符串的操作。例如：

   ```c++
   std::string name = std::string("Cherno") + " hello!";
   bool contains = name.find("no") != std::string::npos;
   std::cout << name << std::endl;
   ```

   name.find 返回的是 no 所在的首位置，std::string::npos 代表的是一个不存在的位置，用 contains 代表结果。


`std::string name = "Cherno" + "hello";`，这样做是不对的，因为双引号里面的是 const char 数组，不是真正的字符串。不能把这两个指针（数组）相加。

可以写成`name += "hello"` 这样做是将一个指针加到了 name 上。name 是一个字符串，你把它加到一个字符串上，+= 这个操作符在 string 类被重载了，所以可以这样写。

常用的一种方式是，`std::string name = std::string("Cherno") + " hello!";` 将两个相加的字符数组的其中一个，显式调用一个 string 构造函数。相当于创建了一个字符串，然后附加这个（字符数组）给它。

## 32.4 字符串传递给其他函数

不会这样做：

```C++
void PrintString(std::string string)
{
	std::cout << string << std::endl;
}
```

- 原因是，这实际上是一个副本。当你把类（对象）传递给一个函数时，你实际上是在复制这个类（对象），而不是直接操作这个对象本身。因此如果你在这个函数里对 string 执行一些操作，并不会影响到传递的原始字符串。
- 显然，这只是一个只读函数。既然并不会对他操作，那为什么还要复制整个字符串呢？这意味着我们必须动态地在堆上，分配一个全新的 char 数组来存储我们已经得到的完全相同的文本，这很影响速度，同时也是一个很常见的短板，因为字符串操作很常见。
- 因此，当你传递一个这样的字符串，而且是只读的情况下，确保通过**常量引用**传递它。因此可以改成这样：`void PrintString(const std::string& string)` ,这告诉我们是一个引用，意味着它不会被复制，而 const 意味着我们承诺不会在这里修改它。虽然承诺不会修改，但其实是可以修改的。

## 注

1. 一个经验法则是，如果你不用 new 关键字，就不要使用 delete 关键字。
2. 内存视图的右边是 ASCII 码表示，左边都是单独的字节。

# 33. C++ 字符串字面量

这是一种基于字符串的东西。**字符串字面量** 是在双引号之间的一串字符。

```C++
//定义一个字符串字面量，通过双引号，然后在之间写点东西。
"Cherno";//这就是一个字符串字面量，它会变成什么，取决于很多因素，悬浮鼠标是 const char [7];
```

- 你会注意到，这里实际上只有 6 个字符，那么为什么是 const char[7]，数组长度为 7 呢？  这是因为在这种情况下，在字符串的最后有一个额外的字符，这是一个空终止字符（\0 或 0）。之所以需要这个，是因为字符串的结束位置是 0，注意不是‘0’。

讲的太细了，不想记了，听一遍吧。

```C++
const char name[8] = "Che\0rno";
std::cout << strlen(name) << std::endl;
结果为：3
```

得到这个结果的原因是它只计算直到 \0 之前的字符数，因为它一旦到 0 它认为结束了（反斜杠\ 是标记转义字符的）。去掉 \0 打印出来的值是 6，也就是字符串的长度而不是 8。

- 去掉 const 后你可能可以对字符串进行修改的操作。但这样可能会出现所谓的未定义行为。这是因为 C++ 标准并没有定义在这种情况下应该发生什么。一些编译器可能会为此生成有效的代码，但你不能依赖它。其他的编译器，甚至不会让你的代码编译通过。
- 未定义是不被允许的。原因是，你在这里所做的是，你取了一个指向那个字符串字面量的内存位置的指针，而字符串字面量是存储在内存的只读部分的。这些字符被嵌入到二进制文件中。当我们引用它的时候，它实际上指的是一个不能被编辑的常量区域。

## 33.1 字符类型

有很多类型的字符：

```C++
const char* name = u8"Cherno";  // 普通的 const char前面也可以加上 u8 后缀。这就是 utf8
const wchar_t* name2 = L"Cherno";  // 宽字符前面需要加一个大写的L：表示下面的字符串字面值由宽字符组成。

const char16_t* name3 = u"Cherno";  // 小写 u,这就是 utf16
const char32_t* name3 = U"Cherno";  // 大写 U，这就是 utf32
```

- 基本上，char 是一个字节的字符、char16 是2个字节的16比特的字符、char32是4个字节的32比特的字符。
- wchar 和 char16 之间的区别是什么？它们都是 2 个字节的字符。虽然默认一个字符是两个字节的，但这实际上是由编译器决定的，它也可能是一个字节。在实际应用中，大多都是2个字节或4个字节的。

  （一般在window上是2个字节，在linux上是4个字节的）。

  因此这其实是一个变动的数值。如果你确实要的是2个字节的，你就用char16_t。

## 33.2 字符附加

在C++14 中，`using namespace std::string_literals;  // 它给出了一些方便的字符串函数` 。

在之前的例子中，`std::string name0 = "Cherno" + " hello";` ，这样是不被允许的，因为这些都是字符串字面量，它们实际上是数组或指针，我们不能将两个指针直接相加。可以这么解决：

```C++
// 用一个构造函数将其包围起来，使其成为一个 string 对象
std::string name0 = std::string("Cherno") + " hello";
// 然而，在C++14 的string_literals库中，有更简便的方法。你可以把字母s加到字符串的末尾。实际上这是一个函数，悬浮鼠标可以发现它是一个操作符函数，返回标准字符串（对象），类似的，如果你把u8放在前面，把L放在前面变成一个宽字符（wstring）或者u 或者U。
std::string name0 = "Cherno"s + " hello";
```

还可以用另一种方法来附加字符串字面量，就是字母 **R**。

```C++
const char* example = R"（Line1
Line2
Line3）";  // R 意味着忽略转义字符，可以直接在里面换行,如果没有的话，你需要这么做

const char* example2 = "Line1\n"
	"Line2\n"
	"Line3\n";
```

## 33.3 字符串字面量的内存

字符串字面量**永远**保存在内存的只读区域内。因为我们写一个 char name 数组。通过汇编代码可以看到这一点。在const segment 内。变量名被设置为 -12，这是一个在栈上声明的变量。

## 注

1. char *p = "hello";   //  p 是一个指针，直接指向常量区，修改 p[0] 就是修改常量区的内容，这是不允许的。
2. char p[] = "hello";   //  编译器在栈上创建一个字符串 p，把 "hello" 从常量区**复制**到 p，修改 p[0] 就相当于修改数组元素一样，是可以的。

# 34. C++ 中的 const（好难，建议再看一遍）

const 在改变生成的代码方面做不了什么，它有点像类和结构体的**可见性**，这是一个可以让我们的代码更干净，并对开发人员写代码强制制定的规则。

const 基本上就像你做出的承诺，它承诺某些东西将是不变的。然而，它只是一个你**可以绕过的承诺**，即你可以打破你的承诺。我们要保持 const 的原因是，它可以简化很多代码。

- 如果你声明一个 `const int a = 99;`，通过写 const，你已经从语法上指定了这个整数是一个常数，而且不能改变它，这应该是一个你需要在程序中保持不变的数字。这是 const 最简单的一种使用方式，即声明一种变量。

## 常量中的const

首先是指针，当你声明一个指针：

```C++
//指针
const int MAX_AGE = 90;
int* a = new int;  // 在堆上创建这个整数，这样我们就能得到一个指针。因为这个声明没有使用 const，因此可以把a 设为别的数

*a = 2;  // 打印 a 的结果为 2
a = (int*)&MAX_AGE;  // 重新分配实际的指针，这样它就会指向别的东西，为了绕开const限制，我把他强制转换成int*类型。此时打印 a 结果为 90
std::cout << *a << std::endl;
```

- 这就是一种违背 const 承诺的方式。你可以看到我们声明 MAX_AGE 是一个 const 常量，很有可能编译器会把它当做一个只读的常量，如果你试着解引用，然后写入，程序可能会崩溃。

- 但上面的代码可以运行，输入结果为 90，这是因为我们在这里做的是重新分配了指针指向。**我们可以改变指针指向的内存的内容，也可以改变指针指向的地址**

现在添加 const：

```C++
const int MAX_AGE = 90;

const int* a = new int;  // 在这里添加 const ,这意味着你不能修改该指针指向的内容
// 上面创建了指针，当我想逆向引用这个指针的时候，然后改变 a 的值，这样是不行的。
// a 的值是实际内存地址上的内容，然而读取 a 是没有问题的

*a = 2;  // 打印 a 的结果为 2
a = (int*)&MAX_AGE;  // 当我尝试改变 a 本身时，没有得到错误。
// 所以如果我让 a 指向其他的比如 MAX_AGE 是没有问题的，我只是不能改变那个指针指向的内容
std::cout << *a << std::endl;
```

使用 const 的第二种方式是把它放在*号后面：

```C++
int const* a = new int;  // 如果你把 const 放在这里，在*号之前，在 int 之后，它的功能和之前的完全一样,也就是和下面的完全一样。
const int* a = new int;  // const int* 和 int const* 完全一样，你只是移动了const
```

但是，如果想让指针本身成为常量，不能重新分配指针指向，你需要**把（const）放在*号后面**，并且在变量名前面，就像下面这样：

```C++
int* const a = new int; //它的作用正好相反：我可以改变指针指向的内容，但我不能把实际的指针本身重新赋值，指向别的东西。

//下面两种赋值都是不行的，我不能让它等于其他任何东西，比如空指针或者其他
a = (int*)&MAX_AGE;
a = nullptr;
//但我可以改变指针指向的内容就像下面这样
*a = 2;

//最后，我可以写 2 个 const，就像这样
const int* const a = new int;//这意味着我不能改变指针指向的内容，也不能改变这个指针本身，让它指向别的
```

这是 const 的第二个用法，当你处理指针时可以是指针本身或者指针指向的内容。当你把 const 放在声明的不同地方，它会具有不同的含义。

## 类和方法中的const

最后，关于 const 的含义是在类中以及方法中（使用 const）。在函数的参数列表后面写上 const。它与变量无关，而是在方法名后面，并且只在类中有效。

在成员函数的声明和定义中使用 `const`，表示该成员函数是一个常量成员函数，不能修改类的成员变量（除非它们是可变的，使用 `mutable` 修饰）。

本例中尝试一种初始化的方法，尝试用**getter和setter**（一种范式）。

**访问器(getter)与更改器(setter)**：

如果确实要在类外部访问和更改私有数据，可以设置`get`/`set`函数

```C++
#include <iostream>
#include <string>

class Entity
{
private:
	//int m_X, m_Y;，如果m_X是一个指针，并且你想让它保持不变，我们让m_X变成一个指针
	int* m_X, m_Y;//然后下面的函数可以写成这样，里面用了3个const
public:
	const int* const GetX() const//这意味着我们返回了一个不能被修改的指针，指针的内容不能被修改
	//int GetX() const//这个方法不会修改任何实际的类，因此你可以看到我们不能修改类成员变量
		//即这个方法不会修改实际的类，只能读不能写
	{
		m_X = 2;//如果我尝试让m_X=2，是做不到的
		return m_X;
	}
	//所以在getter方法之后写const是有意义的，现在试试setter方法呢
	void Set(int x)//不能在后面写const，因为显然要写这个类，所以const一般在getter里。
	{
		m_X = x;
	}

};
```

- `int* m_X, m_Y;`，这里的m_X是指针，但m_Y仍是整型。`int* m_X, *m_Y;`在后面的变量前面也加上一个*号，这样就全是指针了。帮助理解：

```c++
  class MyClass {
  private:
      int value;
  
  public:
      MyClass(int v) : value(v) {}
  
      // 参数为const引用，表示传递的参数不会被修改
      void printValue(const int& v) const {
          std::cout << v << std::endl;
      }
  
      // 返回值为const引用，表示返回的值不能被修改
      const int& getValue() const {
          return value;
      }
  };
  注：
      const int& getValue() const：返回值为 const int& 表示返回的引用是常量，不能通过这个引用修改原值。函数后面的 const 表示这个函数是一个常量成员函数。
```

## 注

1. const 有两层含义，编译期常量和只读变量（编译期常量现在是 constexpr 了）。

2. const记住这个就行：const首先作用于左边的东西；如果左边没东西，就做用于右边的东西

   `const int* a` 表示a指向的地址中的内容不能被修改，可以理解为我把指向内容的int类型声明为const不准修改了，因为const和int在一起；`int* const a` 表示a指向的地址不能修改（不修饰int是因为中间隔了一个*），可以理解为这个const和指针名在一起，表示a存储的值（指向的地址）不能改变。

3. 修改const变量还要加volatile告诉编译器不要优化

   修改const变量本身就是未定义形为。另外，C++中一般只有在一下几种情况才用volatile：1.低级别编程 2.信号处理程序 3.setjmp/longjmp。

4. 加const是个好习惯，c++不允许临时变量作为非const的引用，单纯的引用参数列表很危险，参数传递时很可能会传一些临时变量（常见如未绑定的返回值）而报错

5. 帮助理解第二条

   ```c++
   #include <iostream>
   
   void example() {
       int x = 10;
       int y = 20;
   
       // 指向const int的指针
       const int* ptr1 = &x; // ptr1可以指向x，但不能通过ptr1修改x的值
       // *ptr1 = 15; // 错误：不能通过ptr1修改x的值
       ptr1 = &y; // ptr1可以指向不同的地址
   
       // 常量指针
       int* const ptr2 = &y; // ptr2必须在定义时初始化，且不能指向不同的地址
       *ptr2 = 30; // 可以通过ptr2修改y的值
       // ptr2 = &x; // 错误：ptr2不能指向不同的地址
   
       // 指向const int的常量指针
       const int* const ptr3 = &x; // ptr3必须在定义时初始化，且不能指向不同的地址，也不能通过ptr3修改所指向地址的内容
       // *ptr3 = 15; // 错误：不能通过ptr3修改x的值
       // ptr3 = &y; // 错误：ptr3不能指向不同的地址
   }
   
   int main() {
       example();
       return 0;
   }
   ```

# 35. C++ 的 mutable 关键字

mutable 实际上有两种不同的用途，其中之一是和 **const** 一起使用，另一种是用在 **lambda表达式** 中，或同时覆盖这两种情况。

英语单词 mutable，意味着它是容易改变的东西（不可改变是 immutable）。所以当我们在 const 的背景下谈论可变 mutable 时，我们谈论的就是某种 const，但它实际上又可以改变。我们有一个应用了 mutable 的程序，就是在类方法中。

```C++
class MyClass {
private:
    int value;
    mutable int accessCount; // 可以在const成员函数中修改

public:
    MyClass(int v) : value(v), accessCount(0) {}

    int getValue() const {
        accessCount++; // 可以在const成员函数中修改
        return value;
    }
};
```

- 标记类成员为 mutable，意味着类中的 const 方法可以修改这个成员，这是 mutable 最常见的用法。

## 35.1 lambda 表达式中使用 mutable

lambda 基本上就像一个一次性的小函数，你可以写出来并赋值给一个变量。我们也可以像调用其他函数一样调用它。

```C++
懒得写了
```

## 注

1. 修饰class const方法中class成员变量，使其可以修改。
2. 修饰lambda表达式，值捕获时可以直接操作传入参数。(并非引用捕获，依旧值捕获，不修改原值)

# 36. C++ 的成员初始化列表

构造函数初始化列表，不仅仅是一种风格，而是有它特定的功能在里面的，因此要习惯于使用成员初始化列表，如果不使用它们，就会浪费性能。

（当然不是所有类型的数据都是这样，例如整数，它不会被初始化，除非你通过赋值来初始化它们）

## 36.1 在特定类的情况下

略

## 注

1. 不论你怎么写初始化列表，它都会按照定义类成员的顺序来进行初始化。
2. 构造两次是因为Entity在调用构造函数时首先调用有初始化列表的成员变量，初始化时没在列表中的成员它也初始化，然后再执行花括号里的那就是两次。
3. 初始化const成员变量只能用初始化列表实现，因为不能赋值

# 37. C++ 的三元操作符

所谓三元操作符就是一个问号，一个冒号。

它实际上只是 if 语句的语法糖，我们不处理if和else语句，我们可以写一个问号和一个冒号。根据特定条件给变量赋值，例如：

```C++
if (s_Level > 5)
    s_Speed = 10;
else
    s_Speed = 5;
//上面的表述跟下面是同样的效果

s_Speed = s_Level > 5 ? 10 : 5;

//可表示为：s_Speed = (s_Level > 5) (? 表达式为真) 10 (: 否则) 5
```

再看一个例子吧：`std::string rank = s_Level > 10 ? "Master" : "Beginner";`

```C++
s_Speed = s_Level > 5 ? s_Level > 10 ? 15 : 10 : 5;//大于10，15;5到10之间10；小于或等于5，5
```

- 这里需要考虑运算符的优先级问题。因为有了逻辑和运算符，所以后面这些语句是在前面的逻辑和语句执行之后再执行。
- 这样的代码不仅复杂难懂，还很容易写错。因此，**不要对三元运算符做嵌套**。

# 38. 创建并初始化 C++ 对象

当我们写完一个类，就该开始使用我们创建的类了（除非它是完全静态的），一般需要对它进行实例化。

当我们创建一个 C++，它一定会占用内存。应用程序会将内存主要分为两部分，堆和栈。

（还有一些别的，例如代码区域。）

我们要选择对象是在栈上还是堆上创建，它们有不同的功能差异。例如栈对象有一个自动的生存期。它们的生存期实际上是由它声明的地方作用域决定的，只要变量超出作用域，内存就会被释放。

（因为当作用域结束的时候，栈会弹出，作用域里的东西，也就是栈上的任何东西会被释放。）

但堆不一样，堆是一个很大很神秘的地方。一旦在堆中分配一个对象，实际上你已经在堆上创建了一个对象，直到你释放它。

`using String = std::string`。使用 using 来简化代码，这样就不用到处写：std::string 了，只需要写 string。

## 注

1. 关于为什么不使用 `using namespace std`，之后会对这一点有所解释。
2. 栈通常非常小，只有几兆，取决于你的平台和编译器。
3. 在 java 和 C# 中也可以在栈上创建对象。在 C# 中有一种叫做 struct 的东西，它是基于值的类型，它们实际上是在栈上分配的，即使你使用了 new 关键字。但是在 JAVA 中，所有的东西都在堆上，C# 中所有的类都在堆上。
4. 不要总是用 new, 主要是性能问题，在堆上分配要比栈花费更长的时间，而且在堆上分配的话，你必须手动释放被分配的类型。
5. 利用智能指针，我们实际上仍然可以在堆上进行分配，并且仍然可以获得那种大小优势，还有指针超出作用域时，对象会被自动删除。

# 39. C++ new 关键字

当你在写 C++ 程序时，你应该关注内存，性能和优化等问题。

new 的主要目的是在堆上分配内存。new 就是找到一个足够大的内存块以满足我们的需求，然后给我们一个指向那块内存的指针。下面是使用方法：

```C++
int main()
{
	int a = 2;
	int* b = new int[50];//b 存储内存地址,50*4 = 200 byte

	Entity* e = new Entity[50];//在堆上分配我们的Entity类，括号可以省略(括号相当于默认构造函数)。
	Entity* e = new Entity();// 此时不仅要在堆上分配足够的内存来存储这个Entity，我们也调用构造函数。因为new是一个操作符。

}
```

- new 是一个操作符，这意味着你可以重载这个操作符，并改变它的行为。

  通常，调用new，会调用隐藏在里面的 c 函数 malloc，它代表内存分配以及它的实际作用（传入size，然后返回一个void 指针）

  `ntity* e = new Entity();` 和 `Entity* e = (Entity*)malloc(sizeof(Entity));`基本是一样的，仅有的区别是上一个调用了 Entity 构造函数。**但还是要采用前一种做法**

- 当你采用 new 时，一定要记住的是，使用 **delete**。delete 关键字也是一个常规函数，调用了 C 函数 free，free 可以释放 malloc 申请的内存。
- 使用`new[]`来分配内存，例如`int* b = new int[50]`就需要用`delete[] b`来释放内存。

## 注

1. 空闲链表。placement new：`int* b = new int[50]; Entity* e = new(b) Entity();`
2. 有比较简单的释放内存的策略，比如基于作用域的指针，也有一些高级策略比如引用计数。

# 40. C++ 隐式转换与 explicit 关键字

## 40.1 隐式转换

C++ 允许编译器对代码执行一次隐式转换。

C++ 允许在两个数据类型之间隐式的进行转换，而不需要用 cast 做强制转换。

```C++
class Entity
{
private:
	std::string m_Name;
	int m_Age;
public:
	Entity(const std::string& name):m_Name(name),m_Age(-1) {}  // 传入一个name参数，为m_Name赋值为name

	Entity(int age):m_Name("Unknown"),m_Age(age) {}
};
```

对上面所创建的类实例化：

```C++
第一种方法：比较常用
Entity a("Cherno");
Entity b(22);
第二种：
Entity a = Entity("Cherno");
Entity b = Entity(22);
第三种：这种方法不适用于Java或C#
Entity a = std::string ("Cherno");
Entity b = 22;//这里就发生了隐式转换，它隐式的将22转换成一个Entity，构造出一个Entity。因为有一个Entity的构造函数，接受一个整数的参数；另一个构造函数接受字符串name
```

另一个例子：

```C++
void PrintEntity(const Entity& entity)
{
	//打印
}
调用这个函数，参数22
PrintEntity(22);//这里完全没有报错
```

- 我们没有对这个函数进行重载使它接受一个整数或者类似的东西。但它接受了22。这是因为C++认为22可以转换成一个Entity，因为它可以调用这个构造函数（22是创建的Entity 的唯一参数）

- 但如果是`PrintEntity("Cherno");`则没有成功，是因为这个cherno不是std::string，它是一个char数组。要使它成功运行，需要进行两次转换，但它只允许做一次隐式转换。

  `PrintEntity(std::string("Cherno"));` 或`PrintEntity(Entity("Cherno"))` 这样就可以了。

- 这就是隐式构造函数，可以大大简化你的代码，但一般很少使用。

## explicit 关键字

explicit 与隐式转换有关系，因为 explict 禁用这个隐式implicit的功能。

explicit 关键字放在构造函数前面，这意味着**没有隐式的转换**，如果要使用整数构造这个Entity对象，则必须显式调用此构造函数。

当你写低级封装或者类似的事情时，它可以防止做意外转换，导致性能问题或者bug。

# 41. C++ 运算符及其重载

**运算符**是我们使用的一种符号，通常代替一个函数来执行一些事情，不仅仅是加减乘除，还包括dereference(逆向引用)运算符，箭头运算符，+=运算符，用于地址内存的&运算符，还有我们一直在使用的左移运算符 << ，new，delete等等。

所以，**运算符重载**的本质是给运算符重新赋予新的含义，或者添加参数，或者创建。允许在程序中定义或更改运算符的行为是一个非常有用的特性，但在Java等语言中不受支持，但C++给了我们完全的控制权。

**运算符就是函数**，运算符重载的使用非常少。当定义一个math类，你需要把两个数学对象加在一起，那么将加法进行重载是很有意义的，因为你可以直接a+b。

```C++
struct Vector2
{
	float x, y;
	Vector2(float x, float y):x(x),y(y){ }
	//调用这个Add函数，它接收现有的vector2。通过const引用方式传递，是为了避免复制。
	Vector2 Add(const Vector2& other)const//标记为const，是因为它不会修改这个类。它会创建一个新的vector2作为result结果
	{
		return Vector2(x + other.x, y + other.y);
	}
};
int main()
{
	Vector2 position(4.0f, 4.0f);
	Vector2 speed(0.5f, 1.5f);
	//将它们加在一起并存储结果，在没有运算符重载的语言下，怎么实现呢？你可以写
	Vector2 result = position.Add(speed);
	
	std::cin.get();
}
```

但如果我们想要通过某种修改，来改变speed。使用powerup，我们想要做speed乘以powerup之类的事情。

```C++
Vector2 Multiply(const Vector2& other) const
{
	return Vector2(x * other.x, y * other.y);
}
Vector2 powerup(1.1f, 1.1f);
Vector2 result = position.Add(speed.Multiply(powerup));
```

在C++ 中，因为有运算符重载，因此可以简化。只要对运算符进行重载，就可以改写成：`Vector2 result = position + speed * powerup;`
重载：

```C++
	Vector2 operator+(const Vector2& other)const//operator后面是需要重载的运算符，括号里面是参数。
	{
		return Add(other);
	}// 这里也可以用Add调用+函数：
	// Vector2 Add(const Vector2& other)const
	// {
	// 	return *this + other;//这里this是一个指针也可以写成
	// 	return operator+(other);
	// }
	//乘法：
	Vector2 operator*(const Vector2& other)const
	{
		return Multiply(other);
	}
// 这样就可以：
    Vector2 result = position + speed * powerup;
```

## 左移运算符

`std::cout **<<** result **<<** std::endl;`,因为运算符没有重载，它接受了Vector 和 cout 两个参数，所以会报错。因此我们对他进行重载。

```C++
std::ostream& operator<< (std::ostream& stream,const Vector2& other)
{
	stream << other.x << "," << other.y;
	return stream;
}
```
## bool
```C++
bool operator==(const Vector2& other)const
{
    return x == other.x && y == other.y;
}
bool operator!=(const Vector2& other)const
{
    //return !operator==(other);
    return !(*this == other);
}
```

## 注：
1. operator 重载运算符方式有一些注意事项：既然是用于自建类型的运算，它有两种定义方式。

   作为自建类型的成员函数，定义在类的内部：此时operator的参数数目*比具体重载的运算符操作数数目减一*，因为此时使用的一个隐含参数为*this，并将其作为左操作数（第一个操作数）

   如果需要将*this作为右操作数，只能将operator作为友元函数。

   作为自建类型的友元函数，定义在类的内部或外部，此时operator的参数数目与具体重载的运算操作符数目相同。

2. operator运算符重载有很多限制，基本上只有能重载的只有运算符对操作数的操作。

   具体要求可见链接:https://blog.csdn.net/qq_42683011/article/details/102087764

# 42. C++ 的 this 关键字

通过 this，可以访问成员函数。成员函数意思是一个属于某个类的函数或者方法。

在方法内部，我们可以引用this，**this是一个指向当前对象实例的指针**，该方法属于这个对象实例。

在C++中，我们可以写一个方法，一个非静态方法。为了调用这个方法，首先需要实例化一个对象，然后调用这个方法（这个方法必须用一个有效的对象来调用）。关键字this是指向该对象的指针。

```C++
class Entity
{
public:
	int x, y;
	//Entity(int x, int y) :x(x), y(y)//成员初始化列表
	Entity(int x,int y)
	{
		//如果不用成员初始化列表的话
		this->x = x;//或(*this).x=x
		this->y = y;//如果不用this就无法赋值了
		//这里悬挂鼠标是Entity* 类型的
	}

	int GetX() const//在函数名后加一个const,意味着不能修改这个类
	{
		const Entity* e = this;//所以this 必须是const的
		//e->x = 5;//这样就是不被允许的
		//这里悬挂鼠标可以发现this是const Entity* 类型的。
	}


};
```
- 如果你在一个不是const的函数中访问他，那么它（this）就会是Entity*类型的

另一个有用的场景是，如果我们想调用这个类之外的函数，那就不是类方法了（类的外部叫函数），即**在这个类的内部调用一个类外部的函数，这个函数将Entity作为参数

```C++
//在类内部调用外部函数
PrintEntity(this);//this表示这个类

//如果外部函数采用的是参数引用，那么可以解引用
//Entity& e = *this;
PrintEntity(*this);//一般不要delete this

```
- 通过逆向引用this指针，在非const方法中，可以：`Entity& e = *this;`;
- 在const 方法中可以：`const Entity& e = *this;`；因为这是一个指向当前类（实例）的指针。



# 43. C++ 的对象生存期（栈作用域生存期）

**关于生存期对于基于栈的变量意味着什么**
1. 必须理解栈上的东西是如何存在的，这样你才能写出不会崩溃的，能正常工作的代码。
2. 知道了它是如何运作的之后，就要想办法去利用好它，想出聪明的方法来做事情。

**栈**可以被认为是一种数据结构，你可以在上面堆叠一些东西。每次我们在C++中进入一个作用域，我们是在push栈帧，它不一定非得是将数据推进（push进）一个栈帧。

你在这个作用域下声明的变量，一旦你的作用域结束，就被扔掉了。*你在此作用域下申明的每一个基于栈的变量和创建的对象都消失了*。

**作用域**可以是任何作用域，例如函数作用域（if 语句作用域，for 循环作用域，while 作用域等等），或者空作用域，类作用域。例如下面这个类作用域：

```C++
class Entity
{
private:
	int x;//变量是在栈上创建的
};
```
- 这里的x变量是在栈上创建的，这个变量也在这个类的作用域中，这意味着当这个类消失时，变量也会消失。

下面是第二个例子：
```C++
class Entity
{
public:
	Entity()//构造函数
	{
		std::cout << "created Entity" << endl;
	}
	~Entity()//析构函数
	{
		std::cout << "destroyed Entity" << endl;
	}
};
//如果以下面这种方式声明Entity，就不是将它创建在堆上，而是创建在栈上
//这将调用默认构造函数
{
	Entity e;//这里调用构造函数
}//这里作用域结束，调用析构函数

```

现在对他进行堆分配：

```C++
{
	Entity *e = new Entity();//这里调用构造函数
}//这里被跳过，没有执行析构函数
//即使执行到main函数的}事，也没有执行析构函数，这个entity永远不会被销毁。
```
- 当然了，当应用程序终止时，操作系统会清除这些内存。
- 这就是基于栈的变量和基于堆和变量在对象生存期上的区别。

下面是一个看似合理的操作：
```C++
int* CreatArray()
{
	int array[50];
	return array;
}
//代码是先创建一个数组，然后返回指向该数组的指针。
```
- 首先，创建的这个数组，我们没有在堆上分配它（因为没有使用new），我们只是在栈上声明它，当我们返回一个指向它的指针时，它会返回一个指向栈内存的指针。
- 然而这个栈内存，一旦我们离开作用域，内存就会被清除，因此如果你`int* a=CreatdArry();` 这样写是会失败的。
- 如果你想这样写的话，有两个选择。
  1.  你可以让这个在堆上分配数组，从而确保了它的生存期会一直存在。`int* array = new[50];`
  2.  或者你可以将这里创建的数据复制给一个在栈作用域之外存在的变量。



**在局部创建数组是一个典型的错误**（创建一个基于栈的变量，然后尝试返回指向它的指针）但一旦函数结束，你就超出了作用域。（栈上变量会自动销毁）

但栈上变量也有很多好处，例如：帮助我们自动化代码、比如类的作用域、比如像智能指针smart_ptr、或是unique_ptr（这是一个作用域指针）。或者像作用域缩锁（scoped_lock）。但最简单的例子可能是**作用域指针**

## 作用域指针

它基本上是一个类，一个指针的包装器，在构造时用堆分配指针，然后在析构时删除指针。所以我们可以自动化这个new和delete。

此时我仍然想要在堆上分配这个Entity，但我想在超出作用域之后，自动删除。

```C++
{
	Entity* e = new Entity();
}
```
- 我们可以使用标准库中的unique_ptr，这是一个作用域指针。

现在我们编写自己的代码便于看到它如何工作的，名字为ScopedPtr的类：

```C++
class ScopedPtr
{
private:
	Entity* m_Ptr;//指向Entity的指针
public:
	ScopedPtr(Entity* ptr):m_Ptr(ptr)//将Ptr赋值为ptr
	{

	}

	~ScopedPtr()
	{
		delete m_Ptr;
	}
};
//这是一个基本的作用域指针（类）
此时实例化类时用：
ScopedPtr e = new Entity();//这里存在一个隐式转换，此时这个e一旦超过了作用域，他就会被摧毁。
```
- 这是因为这个ScopedPtr类的对象是在栈上被分配的，这意味着e如果被删除了，当e被自动删除时，在析构函数中，会delete这个被包装的entity指针。尽管实例是在堆上创建的。
- 上述是smart_ptr，unique_ptr做的最基本的事情。
- 这种自动构造，自动析构，这种基于栈的变量，离开作用域后会被销毁，是非常有用的。

## 注
1. **互斥锁**：如果你想锁定一个函数，以便多个线程可以同时访问它而不会爆炸。你可以有一个自动作用域锁定。


# 44. C++ 的智能指针
我们知道new是在堆上分配内存，需要delete来删除内存，释放内存，因为它不会自动的释放内存。

智能指针是实现这一过程自动化的一种方式：当你调用new时，你不需要delete，在很多情况下使用智能指针，我们甚至不需要调用new。

**智能指针**本质上是一个原始指针的包装，当你创建一个智能指针，它会调用new并为你分配内存，然后基于你使用的智能指针，这些内存会在某一时刻自动释放。

## unique_ptr

第一个，也是最简单的智能指针unique_ptr，unique_ptr是作用域指针，是超出作用域时，它会被销毁，然后调用delete。

**unique_ptr必须是唯一的**，你不能复制一个unique_ptr，因为如果你复制一个unique_ptr，那么它们指向的内存是同一个（此时你会有两个指针，两个unique_ptr指向同一个内存块），如果其中一个死了，它会释放那段内存。也就是说：你指向同一块内存的第二个unique_ptr指向了已经被释放的内存。因此你不能复制unique_ptr。

unique_ptr是你想要一个作用域指针的时候，它是你唯一的参考。下面是一个例子：

```C++
	{//建立一个空作用域
		//std::unique_ptr<Entity> entity = new Entity();//这样是不行的,因为unique_ptr它的构造函数时explict的，这意味着它需要显示调用构造函数。没有构造函数的隐式转换。
		std::unique_ptr<Entity> entity(new Entity());//<>里面是数据类型，后面是你为他取得名字

		entity->Print();//这样就可以像一个原始指针一样去使用它。
	}
//也可以这样
{
		std::unique_ptr<Entity> entity = std::make_unique<Entity>();
		//这很重要，主要出于异常安全。因此最好的办法就是调用make_unique，因为如果构造函数碰巧抛出异常，它会稍微安全一些
		//他保护你最终不会得到一个没有引用的悬空指针，从而造成内存泄漏。
		entity->Print();
}
//当作用域结束时，我们的Entity会被自动摧毁。
```
- 但这个指针不可以被传递到一个函数中，或者另一个类中，因为它不能被复制：`std::unique_ptr<Entity> e0 = entity;`这样会得到一个错误信息。
- 如果你想使用这样的功能，可以考虑共享指针shard_ptr。

## shared_ptr

shared_ptr 实现的方式实际上取决于编译器和你在编译器中使用的标准库，但几乎所有的编译器中，它使用的都是**引用计数**。

引用计数基本上是一种方法，可以跟踪你的指针有多少个引用，一旦引用计数达到零，它就被删除了，内存就会被释放。

```C++
{
	std::shared_ptr<Entity> sharedEntity = std::make_shared<Entity>();//最好使用这种方式

	std::shared_ptr<Entity> sharedEntity(new Entity());//最好不要这样
	//在unique_ptr中，不直接调用new的原因是因为异常安全。但在shared_ptr是因为别的原因。
}
```
- shared_ptr 需要分配另一块内存，叫做控制块，用来存储引用计数。如果你首先创建一个new Entity，然后将其传递给shared_ptr构造函数，这样它必须做2次内存分配（第一次是new Entity的分配，第二次是shared_ptr的控制内存块的分配）使用make_shared可以更有效率的把它们组合起来。
- 有了共享指针，你就可以进行复制，`std::ushared_ptr<Entity> e0 = sharedEntity;`。

```C++
{
	std::shared_ptr<Entity> e0;
	{
		std::shared_ptr<Entity> sharedEntity = std::make_shared<Entity>();
		e0 = sharedEntity;
	}
}//这个可以验证，当所有的引用都消失了，当所有追踪shared_ptr的栈分配对象死亡后，从内存释放后，那就是你的底层Entity被删除的时候。
```
还有一个可以和shared_ptr一块儿使用的，叫做弱指针

## weak_ptr

它只是像声明其他东西一样声明，可以给他赋值为sharedEntity

```C++
std::weak_ptr<Entity> weakEntity = sharedEntity;
```

- 这里所做的，和之前复制sharedEntity所做的一样，但之前会增加引用计数，但这里不会。
- **当你将一个shared_ptr赋值给另外一个weak_ptr，不会增加引用计数**。

**当**你要声明一个堆分配的对象，并且你不希望自己来清理，因为你不想显式的调用delete，或者显式的管理内存时，你就应该使用智能指针。

尽量使用unique_ptr，因为它有一个较低的开销；但如果你需要在对象之间共享，不能使用unique_ptr的时候，就使用shared_ptr。

## 注
1. make_unique<>() 是在C++14引入的，C++11并不支持。
2. 要多去使用这些智能指针，它们会使你的内存管理自动化，它们防止你因为忘记调用delete，而意外的泄漏内存。

# 45. C++ 的复制与拷贝构造函数

拷贝指的是要求复制数据，复制内存。下面我会通过一个字符串类来说明复制在C++中是怎么产生作用的，以及如果我们要添加复制，如何正确的复制。

```C++
int a = 2;
int b = a;
b = 3;
```
- 这里实际上是创建了一个a的副本，a 和 b是两个独立的变量，它们有不同的内存地址。
- 由于这个原因，如果我将b=3,a仍然是2。内存中有两个值。

```C++
struct Vector2
{
	float x, y;
};
int main()
{

	Vector2 a = { 2,3 };
	Vector2 b = a;
	b.x = 5;

	std::cin.get();
}
```
- 类中也是一样的，修改b.x=5，a.x中的值仍然为2。
- 因为这样做，我**复制的是值**，就像那个整数的例子一样。它们是两个独立的变量，占用了两个不同的内存地址。

如果你要在堆中使用new关键字来进行分配。

```C++
Vector2* a = new Vector2();
Vector2* b = a;
b++;b->x=2;//
```

- 这里将b复制为a，情况就完全不同了，因为现在的Vector2是一个指针了，`Vector2* b = a;`这里是在复制一些东西，但我没有复制实际的向量（向量里面包含了x和y变量），我实际上复制了指针。
- 所以现在我有两个指针，它们本质上有相同的值。因为它们指向相同的内存。
- 如果我用b++来修改指针，我的a指针仍然是完整的。但是如果我访问这个内存地址，设置为某个值，在这种情况下，是会同时影响a和b的。因为它们指向同一个内存地址。我在这里做的是不是影响指针，而是影响内存地址。

**这**很重要，当你使用赋值操作符，将一个变量设置为另一个变量时，你*总是*在复制值。除了引用，因为如果你给其他东西复制一个引用，把一个引用赋值为另一个引用，你实际上是在改变指向（因为引用只是别名，并没有复制），所以引用除外。

当你编写一个变量被赋值另一个变量的代码时，你总是在复制值。在指针的情况下，你在复制指针，也就是内存地址或内存地址的数字而已，而不是指针指向的实际内存。

考虑到这一点，我们来写一个字符串类，看看我们怎样才能使得它具有**可复制性**，以及我们可能会面临哪些挑战。

写一个基本的字符串类的实现，使用C++原始特性。

```C++
#include <iostream>
#include <string>
class String//字符串是一组字符组成的
{
	/*1. 放置一个字符数组
	* 2. 计算这个字符串有多长，这样我们就可以把这个字符串的数据复制到缓冲区
	* 3. 把这个指针复制到我们实际的缓冲区中，这样缓冲区就会被我们的字符填充
	* 
	**/
private:
	char* m_Buffer;//指向字符缓冲区
	unsigned int m_Size;//保存string的大小
public:
	String(const char* string)
	{
		m_Size = strlen(string);//c函数strlen可以得到string的大小
		m_Buffer = new char[m_Size];//我们实际上还需要一个空终止符，所以应该加1.
		//for (int i = 0; i < m_Size; i++)
		//	m_Buffer[i] = string[i];//一个一个复制，或者用下面更简单的函数
		memcpy(m_Buffer, string, m_Size);//第一个参数是目的des,来源，大小。记住这个size其实少了一个空终止符的大小
	}
	friend std::ostream& operator<<(std::ostream& stream, const String& string);//命名为友元

};
//使用标准的std::cout(来打印字符串)首先重载左移操作符，
std::ostream& operator<<(std::ostream& stream, const String& string)
{
	stream << string.m_Buffer;
	return stream;
}
//我们可以将这个运算符的重载（函数）作为这个类的友元，这样我们就可以在GetBuffer这个函数中访问m_Buffer,
int main()
{
	
	String string = "Cherno";
	std::cout << string << std::endl;//结果为：Cherno葺葺葺稕O?。后面有很多随机字符，这是因为我们没有空终止字符
	std::cin.get();
}
结果为：Cherno葺葺葺稕O?。后面有很多随机字符，这是因为我们没有空终止字符。首先去把这个空终止字符添加上。
//只需要修改下面这两行
m_Buffer = new char[m_Size + 1];//size+1,为终止字符腾出空间。或者使用strcpy函数（拷贝时包含了空终止字符）
memcpy(m_Buffer, string, m_Size+1);//这样运行后可以正常工作
//或者memcpy(m_Buffer, string, m_Size); m_Buffer[m_Size] = 0;//手动在最后添加自己的空终止符
//但这是在一个假设的基础上，假设这个char* string字符串能正常的通过空终止字符结束。如果不能保证这一点的话。就在后面添加
```
- 这是最基本的String类设置。实际上上面有一个内存泄漏，我们应该修复一下。那就是我们分配的这个new char，我们没有用delete。当然如果你用智能指针或者vector，你是不需要用delete的。因此需要添加一个析构函数来delete。
```C++
~String()
{
    delete[] m_Buffer;
}
```

**经**过上述修改后，此时的string类已经具有可复制性。

```C++
#include <iostream>
#include <string>
class String//字符串是一组字符组成的
{
private:
	char* m_Buffer;//指向字符缓冲区
	unsigned int m_Size;//保存string的大小
public:
	String(const char* string)
	{
		m_Size = strlen(string);
		m_Buffer = new char[m_Size + 1];//size+1,为终止字符腾出空间。或者使用strcpy函数（拷贝时包含了空终止字符）
		memcpy(m_Buffer, string, m_Size);
		m_Buffer[m_Size] = 0;
	}
	~String()
	{
		delete[] m_Buffer;
	}
	friend std::ostream& operator<<(std::ostream& stream, const String& string);//命名为友元
};
std::ostream& operator<<(std::ostream& stream, const String& string)
{
	stream << string.m_Buffer;
	return stream;
}
int main()
{
	String string = "Cherno";
	String second = string;
	std::cout << string << std::endl;
	std::cout << second << std::endl;
	std::cin.get();
}
```
- 执行后Cherno被打印了两次，这是我们所期望的，但当我敲完回车，代码执行完进入cin.get()之后，代码崩溃了。
- 我们在这里`String second = string;`做的是复制这个String,当我们复制这个String的时候，C++自动为我们做的是：它将所有的类成员变量，这些成员变量组成了类（实例的内存空间），他将这些值，复制到一个新的内存地址里面，这个新的内存地址包含了second（string）字符串。
- 现在内存中有两个string，因为它们直接进行了复制，这种复制称为**浅拷贝（shallow copy）**，它所做的是复制这个指针，因此内存中的这两个String对象，有相同的char*的值。
- 换句话说，这个m_Buffer的内存地址，对于这两个String（对象）来说是相同的。
- 程序会崩溃，是因为当我们到达作用域的尽头时，这两个String都被销毁了。析构函数会被调用，然后执行 delete[] m_Buffer 两次，程序试图两次释放同一个内存块。
- 我们真正需要做的是，分配一个新的char数组来存储复制的字符串。而我们现在做的是复制指针，两个字符串对象指向完全相同的内存缓冲区。也就是说，当我们想要改变其中一个的时候，他同时改变了它们，因为它们指向同一个字符串。删除同理。

**修改字符串**涉及到的操作：
```C++
second[2] = 'a';//这里的[]需要进行操作符重载

char& operator[](unsigned int index)
{
    return m_Buffer[index];
}
```

## 深复制

**但是！！！** 我们想要复制内存块，希望第二个字符串拥有自己的指针，也拥有自己唯一的内存块。当我们修改或删除第二个字符串时，他不会影响第一个字符串，反之亦然。

我们能做到这一点的方法，是执行一种叫做 **深度复制（深拷贝）** 的东西。也就是说我们实际上复制了整个对象。

**深拷贝是：根据定义，复制整个对象**

- 执行深拷贝的方法很多，我们可以写出克隆，比如用方法或函数，或者类似的东西，然后让它返回一个新字符串。这里我们采用的方法是，**拷贝构造函数**。
- 拷贝构造函数是一个构造函数，当你复制第二个字符串，它会被调用。

  当你把一个字符串赋值给一个对象时。（这个对象）也是一个字符串。当你试图创建一个新的变量并给它分配另一个变量时，这个变量和你正在创建的变量有相同的类型。

  你复制这个变量，也就是所谓的拷贝构造函数，
- C++ 在默认情况下会为你提供一个拷贝构造函数。你可以使用拷贝构造函数做下面几件事：拷贝构造函数的定义和声明。

```C++
String(const String& other);//拷贝构造函数的函数签名，对同样的类对象的常引用const &
```
它所做的就是内存复制，将other对象的内存，浅层拷贝进这些成员变量。如果我们自己写这个函数的话，它可能会长这样：

```C++
String(const String& other) :m_Buffer(other.m_Buffer), m_Size(other.m_Size)
{

}
//这就是C++默认提供的拷贝构造函数。或者下面这样：
String(const String& other)
{
    memcpy(this, &other, sizeof(String));
}
```
- 这样做是不行的，因为我们不仅仅想复制指针，我们想复制指针所指向的内容，因此，如果我们决定不需要拷贝构造函数，不允许复制，我们可以将这个拷贝构造函数声明为delete。`String(const String& other) = delete;`这样下面执行的复制字符串操作就会报错。
- 这就是 unique_ptr 所做的，禁用拷贝复制函数。我们需要在这里找到我们的拷贝构造函数，进行深拷贝。

```C++
String(const String& other)
    :m_Size(other.m_Size)//这里我要做的是复制m_Size
    {
        m_Buffer = new char[m_Size + 1];//分配一个新的缓冲区
        memcpy(m_Buffer, other.m_Buffer, m_Size);
        //这里已经有了一个空终止字符，因为它是一个字符串，必须有空终止字符。但我的好像不是这样。后面出现乱码了。所以我手动添加一个空终止字符
        m_Buffer[m_Size] = 0;
    }
```
这就是执行深拷贝，所必须使用的代码。结果为：Cherno   Charno。并且当我按下enter，它不会崩溃。我们的程序成功终止了。

```C++
String(const String& other)
    :m_Size(other.m_Size)//这里我要做的是复制m_Size
    {
        std::cout << "copy String" << std::endl;

        m_Buffer = new char[m_Size + 1];//分配一个新的缓冲区
        memcpy(m_Buffer, other.m_Buffer, m_Size);
        //这里已经有了一个空终止字符，因为它是一个字符串，必须有空终止字符。
        m_Buffer[m_Size] = 0;
    }

void PrintString(String string)
{
	std::cout << string << std::endl;
}

int main()
{
	String string = "Cherno";
	String second = string;//你执行这一步，它将复制字符串。如果你想要写一个Print函数。在上面两行
	second[2] = 'a';//这里的[]需要进行操作符重载

	PrintString(string);
	PrintString(second);//这样打印出来似乎没有问题，但我们实际上不必要复制这个。如果我们在拷贝函数中写上一个提示信息。
	//String second = string;这里看上去只做了一次复制，但当我们把它传递给这个PrintString函数时，我们实际上做了额外2次复制操作。

	std::cin.get();
}
```
- 运行后可以发现我们有三个String的复制，但我们并不需要做这些复制，因为当我们每次复制一个字符串时，我们都是在堆上分配内存（复制所有内存，并且最后释放内存），这完全没有必要。
- 我们真正想做的是：现有的字符串直接进入这个PrintString函数。因为我们知道我们不需要它的另一个副本。我们可以直接引用现有的string。方法就是**直接传引用**。这个String类实际上不会修改字符串，所以我们应该标记为const引用。
- 如果我们不标记的话，我们就可以对它进行修改，并且编辑现有的字符串。
- 除此之外，也意味着我们可以将临时的**右值**，传递到实际的函数中。

```C++
void PrintString(const String& string)
{
	std::cout << string << std::endl;
}
```
- 也就是，如果我们改变这个函数签名，接受一个字符串的const引用，而不仅仅是一个字符串，这样运行之后可以看到，只发生了一次复制。而这个复制发生在我们给第二个对象赋值为string时（这就是必须要进行复制的那一步）。
- 如果我们临时决定在PrintString函数中复制字符串，只需要添加`String copy = string;`就可以。
- 因此，最好**通过const引用传递对象！！！**这涉及到一些关于优化的知识。（但有的情况下，复制可能会更快）。但无论如何，在基础使用中，用它（const 引用）更好。因为你写的函数本身，你可以决定在函数的内部是否要复制，但你没有理由到处复制，它们会拖慢你的程序。

## 注

1. 关于**左值和右值**，以后会学习到的。
2. 下面是本节内容所用到的代码文件
   
```C++
#include <iostream>
#include <string>
class String//字符串是一组字符组成的
{
private:
	char* m_Buffer;//指向字符缓冲区
	unsigned int m_Size;//保存string的大小
public:
	String(const char* string)
	{
		m_Size = strlen(string);
		m_Buffer = new char[m_Size + 1];//size+1,为终止字符腾出空间。或者使用strcpy函数（拷贝时包含了空终止字符）
		memcpy(m_Buffer, string, m_Size);
		m_Buffer[m_Size] = 0;
	}

	String(const String& other)
		:m_Size(other.m_Size)//这里我要做的是复制m_Size
	{
		std::cout << "copy String" << std::endl;

		m_Buffer = new char[m_Size + 1];//分配一个新的缓冲区
		memcpy(m_Buffer, other.m_Buffer, m_Size);
		//这里已经有了一个空终止字符，因为它是一个字符串，必须有空终止字符。
		m_Buffer[m_Size] = 0;
	}

	~String()
	{
		delete[] m_Buffer;
	}

	char& operator[](unsigned int index)
	{
		return m_Buffer[index];
	}

	friend std::ostream& operator<<(std::ostream& stream, const String& string);//命名为友元
};
std::ostream& operator<<(std::ostream& stream, const String& string)
{
	stream << string.m_Buffer;
	return stream;
}

void PrintString(const String& string)
{
	//String copy = string;
	std::cout << string << std::endl;
}

int main()
{
	String string = "Cherno";
	String second = string;
	second[2] = 'a';//这里的[]需要进行操作符重载

	PrintString(string);
	PrintString(second);

	std::cin.get();
}
```

# 46. C++ 的箭头操作符

本节我们将讨论箭头运算符，对于结构体与类的指针，可以做什么。然后实现我们自己的运算符（重载）。

```C++
int main()
{
	Entity e;
	e.Print();
	//但如果这个Entity对象实际上是一个指针的话，所以要么是在堆上分配,要么是因为某种原因，我有一个指向它的指针

	Entity* ptr = &e;
	ptr->Print();//此时调用Print函数不能使用点，而应该是箭头。
	//因为这只是一个指针，也就是一个数值（不是对象，所以不能调用方法），
	//实际上我们需要逆向引用（*ptr）像下面这样
	Entity* ptr = &e;
	Entity& entity = *ptr;
	entity.Print();
	//我们还可以使用指针
	(*ptr).Print();

	std::cin.get();
}
```
- 可以看出，我们还是使用箭头操作符比较好，这实际上就相当于逆向引用了Entity指针然后调用Print。所以这实际上是一个快捷方式。
- 这基本上是箭头操作符的默认用法了。

## 重载 -> 运算符
**然而**，作为一个运算符（操作符），C++实际上可以**重载**它，并在你自己的自定义类中使用它。
```C++
//在class ScopedPtr里面加上一个返回 Entity 指针的函数
	Entity* GetObject()
	{
		return m_Obj;
	}
//然后就可以调用Print函数了，但是比较麻烦，如下所示：
	entity.GetObject()->Print();
//但如果我希望可以直接写的简单一点，比如：
	ScopedPtr entity = new Entity();
	entity->Print();
```
这样我们需要对->进行重载，就像下面这样：

```C++
	Entity* operator->()
	{
		return m_Obj;
	}
	//这样就可以
	ScopedPtr entity = new Entity();
	entity->Print();
//它可以编译并正确运行，并打印出Hello
```
如果这是const，你也可以给出这个运算符的const版本

```C++
	const Entity* operator->() const
	{
		return m_Obj;
	}
	//
	const ScopedPtr entity = new Entity();
	entity->Print();//此时Print也需要改成const类型，否则不能被调用
```
这就是重载箭头运算符的方法，对于你自己类中的函数，这很强大。因为你可以在你自己的类型中，定义自己的构造函数并实现自动化，但看起来像普通的代码。

```C++
#include <iostream>
#include <string>
class Entity
{
public:
	int x;
public:
	void Print() const
	{ 
		std::cout << "Hello" << std::endl; 
	}
};
//写一个智能指针的类,当我的Entity超出范围时，这个类会自动删除它。
class ScopedPtr
{
private:
	Entity* m_Obj;
public:
	ScopedPtr(Entity* entity)
		:m_Obj(entity)
	{

	}
	~ScopedPtr()
	{
		delete m_Obj;
	}
	/*Entity* operator->()
	{
		return m_Obj;
	}*/
	const Entity* operator->() const
	{
		return m_Obj;
	}
};
int main()
{
	/*ScopedPtr entity = new Entity();
	entity->Print();*/
	//现在我希望能够调用Entity里的Print函数，这个函数将访问这个x变量。此时我不能使用圆点。但我可以将m_obj变成public的，而且可以返回一个Entity指针，就像GetObject这样。
	//entity.GetObject()->Print();
	const ScopedPtr entity = new Entity();
	entity->Print();//此时Print也需要改成const类型，否则不能被调用
	
	std::cin.get();
}
```

## 使用 -> 运算符

你还可以实际使用箭头操作符，来获取内存中某个成员变量的偏移量，这其实是一个额外的部分，但跟箭头操作符有关。
```C++
#include <iostream>
#include <string>

struct Vector3//这个结构体是由浮点数构成的
{
	float x, y, z;//浮点数每一个有四个字节，所以x的偏移量是0，因为在结构体的第一项；同理y的偏移量是4个字节，z的偏移量会是8
	//float x, z, y;
	//在类中，它们的工作方式是一样的，但它们在内存中会有不同的布局。
};
```
现在我想写一些东西，来告诉我这些成员的偏移量，我就可以使用**箭头运算符**做一些类似的事情。

我想做的是访问这些变量，但不是通过有效的内存地址，地址从零开始。

```C++
//先写一个0，然后把它转换成一个Vector3指针,然后用箭头访问x，将会得到这些内存的布局，
//我要做的是取这个x的内存地址，因此用&取地址符，然后得到这个x的偏移量，因为我从0开始，所以0也可以换成nullptr，最后我把它转换成int类型，然后让它等于offset。
int offset = (int)&((Vector3*)nullptr)->x;
std::cout << offset << std::endl;
//打印出来是 0，将x改成y，结果是4，换成z，结果是8。
//这样看起来是正确的
```
- 所以我们在这里所做的是，我们**使用了箭头运算符来获取内存中某个值的偏移量**，这是非常有用，当你把数据序列化为一串字节流，当你想要计算某些东西的偏移量。当我们开始做图形编程，游戏引擎系列的时候。我们会接触到这种令人兴奋的代码，因为我们总是要处理字节流。（嚯，好厉害呀）

# 47. C++ 的动态数组（std::Vector）

现在我们终于开始写一些 C++ 标准库的东西啦！（开心吼）。

**模板可以处理你提供的底层数据类型**，这意味着你不需要自己编写自己的数据结构或者类似的东西。所以C++提供给我们一个叫做Vector的类，这个Vector在std命名空间中。其实它本应该被称作ArrayList，因为这更有意义，它**本质上是一个动态数组**，而不是向量。

- Vector 有点像一个集合，一个不强制其实际元素具有唯一性的集合。
- 它基本上是一个数组，但与普通数组不同，他可以调整数组大小，所以*一般情况下，创建 Vector 数组时不需要给定大小*。
- 当vector内的元素个数超过容量时，它会在内存中创建一个比第一个大的新数组把所有东西都复制到这里，然后删除旧的那个。因此可以不断的向里添加新的东西。

## 创建动态数组

我们需要一种方式，当你到达它们的最大容量时，重新调整容量，使得容量变得更大，这样你就可以存储更多的数据。解决办法是分配动态数量的vertex。

case1：

```C++
int main()
{
	Vertex* vertices = new Vertex[5];//在堆上创建静态数组也需要分配大小。此处分配5个Vertex
	std::cin.get();
}
```
case2:
```C++
//输出运算符重载
std::ostream& operator<<(std::ostream& stream, const Vertex& vertex)
{
	stream << vertex.x << ", " << vertex.y << ", " << vertex.z;
	return stream;
}
int main()
{
	//创建动态数组
	std::vector<Vertex> vertices;//<>内是数组中元素的类型，这里是Vertex,但在Java中不能这样传递类型模板
	vertices.push_back({ 1, 2, 3 });
	vertices.push_back({ 4, 5, 6 });

	for (int i = 0; i < vertices.size(); i++)
	{
		cout << vertices[i] << endl;
	}//这里也可以写基于range的for循环语句，更简洁。
	for(Vertex v :vertices) cout << v << endl;
	//如果我们想清除vertex列表，我们只需要输入
	vertices.clear();//这样会将数组大小设回0.
	vertices.erase(vertices.begin()+1)//单独移除某个元素,这里看函数签名可以知道不能直接填写数字，而是需要使用迭代器。2可以用vertices.begin()+1来表示。
	std::cin.get();
}
```
tip 1:

当你将这些vector传递给函数或类或者其他东西时。你要确保你是通过引用传递它们的，如果你不修改它们，那么用const引用。这样可以确保你没有把整个数组复制到这个函数中。就像这样：`void function(const std::vector<Vertex>& vertices){}`

## 注
1. 静态操作更节省时间。vector通常情况下比较慢。
2. 缓存线。
3. 虽然指针在扩展数组大小时更加方便和快速。但尽量使用对象而不是指针。就像栈分配和堆分配一样。指针是最后的选择。

# 48. C++ 的std::vector使用优化

优化最重要的规则之一，就是最好的了解你的环境。std::vector类的工作方式如下：

1. 你创建一个vector，然后开始push_back元素（也就是往数组中添加元素）
2. if vector 的容量不够大，不能容纳你想要的新元素，那么 vector 需要分配新的内存，至少需要容纳这些想要加入的元素。
3. 具体方法是将内存中的旧位置复制到内存中的新位置，然后删除旧位置的内存。
4. 这也是使用vector会将代码拖慢的原因之一。

因此，如何避免复制对象是优化的目标之一。因此了解什么时候发生了复制非常重要。

```C++
struct Vertex
{
	float x, y, z;
	
	Vertex(float x, float y, float z) :x(x), y(y), z(z)
	{
	}
	Vertex(const Vertex& Vertex) :x(Vertex.x), y(Vertex.y), z(Vertex.z)
	{
		cout << "Copied" << endl;
	}
};

int main()
{
	//创建动态数组
	std::vector<Vertex> vertices;
	vertices.push_back(Vertex{ 1, 2, 3 });
	vertices.push_back(Vertex{ 4, 5, 6 });
	vertices.push_back(Vertex{ 7, 8, 9 });

	std::cin.get();
}

```

这里的 Vertex 被复制了六次，为什么？通过调试可以知道：

- 当我们创建 vertex 时，我们实际上是在主函数的当前栈帧中构造它，即我们在main的栈上创建它，然后我们需要把它放到这个vector中，所以我们需要从那个main函数中（把这个创建的Vertex）放到实际的Vector中（即vector分配的内存中）也就是我们将它（vertex）从main函数复制到vector类中。
- **这是可以优化的第一件事情**：如果我们在适当的位置构造那个vertex，在vector分配的内存中。

继续调试可以发现第二个push处，出现了两份拷贝，这样加上第一行的就一共是三个了。那么多余的一个复制是怎么来的呢？

- 鼠标放到vertex上可以发现实际的vertex vector的capacity容量为2，这意味着这个vector在物理上有足够的内存在存储两个顶点（对象）
- 所以这里发生的事情是，当我们尝试再push一个，比如这第三个，然后开始运行，它需要将容量调整到3或者更高的值，这样我们就能有足够的内存来放入我们的第三个顶点vertex。
- **这是另一个潜在的优化策略**：我们的vector在这里调整了2次大小。如果我们知道我们计划放进三个vertex对象，从一开始就给3个元素留下足够的内存。**这是第二种优化策略**。

这就是这6个copy的来源，这时可以做一个快速且简单的优化策略。使得vector容量为3的方法是我们设置 vertices.reserve(3)，这里的3就是要设置的容量。

- 这与调整大小（resize），或在构造函数中传入3是不同的。
- 如果这个3是在构造函数中的，那么就会得到vertex，没有正确的默认构造函数可用，因为这实际上不仅仅是分配足够的内存来存储三个vertex对象，它实际上会构造三个vertex对象，但我们并不想构造这么多对象，我们只是想要有足够的内存来容纳它们。
- 这就是reserve所做的，reserve可以确保我们有足够的内存，所以第一步是我们创造vertices vector，然后我们reserve 3，然后我们把元素push_back；加入reserve后，copy为3，如果不加的话，copy数量就会指数级增长。但我们仍然可以做的更好

由于这个vertex是在main函数中构造的，然后复制到实际的vector中，那么我想在实际的vector中构造，我们可以使用**emplace_back**，而不是push_back；就像这样：

```c++
std::vector<Vertex> vertices;

vertices.reserve(3);

vertices.emplace_back(1, 2, 3);
vertices.emplace_back(4, 5, 6 );
vertices.emplace_back(7, 8, 9 );
```

在这种情况下，不是传递我们已经构建的vertex对象，我们只是传递了构造函数的参数列表，这样在我们实际的vector内存中就会使用以下参数去构造一个vertex对象。此时可以发现copy为0；

**此时这段代码会比我们最初的代码运行快的多，这就是优化**：只要知道实际上发生了什么，并了解我们的环境，知道如何使用可用的工具来优化它。

## 注

1. 拷贝函数



# 49. C++中使用库（静态链接）

我们可以采取一些策略，当我们在处理C++库时，个人更喜欢在存储库中有需要的所有东西，以便于你能够直接编译和运行项目中的应用程序。cherno 倾向于在实际解决方案中的实际项目文件夹中，保留使用库的版本。

在 VStudio 中，你可以添加另一个项目，该项目包含你的依赖库的原代码，然后将其编译为静态或者动态库。如果是一个快速项目，那么可以链接二进制文件，因为它会更快更容易。

今天，我们将以二进制文件的形式进行链接，而不是获取实际依赖库的源代码并自己编译。现在只讨论处理二进制也就是GLFW库。但在实际的项目中，或者你想要链接的库中，二进制文件可能不可用，所以实际上你可能会被迫自己去构建它。

而自己编译有助于调试或者修改。



## C++ 库的典型组织结构

库通常包含有两部分，includes 和 library，**包含目录**和**库目录**。包含目录是一堆头文件，这样我们就可以实际使用预构建的二进制文件中的函数；然后lib目录有那些预先构建的二进制文件

这里通常有两个部分，动态库和静态库（但并不是所有的库都提供这两种库），因此你可以选择动态链接或者静态链接。

1. 静态链接意味着这个库会被放到你的可执行文件中，它在你的exe文件中。
2. 而动态链接是在运行时被链接的，所以你仍然有一些链接，你可以选择在程序运行时，装载动态链接库。
3. 有一个叫做 loadlibrary 的函数，你可以在 WindowsAPI 中使用它作为例子，它会载入你动态库，可以从中拉出函数，然后开始调用函数。你也可以在应用程序启动时，加载你的dll文件，这就是动态链接库。

主要区别就是：库文件是否被编译到exe文件中或链接到exe文件中，还是只是一个单独的文件，在运行时你需要把它放在你的exe文件旁边，然后你的exe文件可以加载它。

这两种是不同的东西。因为这种依赖性，你需要有 exe 文件和 dll 文件在一起。

- 静态链接在技术上更快，因为编译器或链接器实际上可以执行链接时优化之类的。
- 静态链接在技术上可以产生更快的应用程序，因为有几种优化方法可以应用。
- 而对于动态库，我们必须保持它的完整，当（动态链接）库被运行时的程序装载时，程序的部分将被补充完整。
- 所以通常情况下，静态链接是最好的选择。
- 链接成功后，不会出现报错，我们可以使用库里面包含的函数。和我们在有文件头时候得到的结果一样。

**这些头文件，你可以自己写里面的内容。不论是库的链接也好，还是头文件也好，它们只是将系统的所有组成部分连接在一起**。

头文件通提供声明，告诉我们哪些函数是可用的（插桩）；然后库文件为我们提供了定义，这样我们就可以链接到那些函数，并在C++中调用函数时执行正确的代码。

## 注

1. 指定附加文件时使用相对路径，可以通过使用宏 `$SolutionDir` 或类似于 `$ProjectDir` 之类的。 
2. 在添加头文件时使用`include "GLFW/glfw3.h"` ，因为这是一个编译器指定的包含路径，这里也可以用尖括号。
3. 关于是否应该使用尖括号或者引号的问题，实际上这两者没什么区别：如果是引号的话，会先检查相对路径，如果它没有找到任何相对这个文件的东西，也就是相对于main.cpp文件，它就会去找编译器，检查编译器的include路径。
4. **Tips**：如果这个源文件在VStudio中，只要在这个解决方案中就用引号。如果它是一个完全的外部依赖或者外部的库，不在VStudio中和我的实际解决方案一起编译，那么就用尖括号，来表示他实际上是外部的。
5. 仅仅将头文件包含，可能会编译通过，但是在生成解决方案时会出现链接错误，这是因为.h文件只提供了函数的声明，没有函数的定义，因此需要链接到实际的函数定义的库中才行，在编译器的属性linker项中包含lib文件即可。（**指定一个库目录和相对于那个库目录的库文件的名称**）



# 50. C++ 中使用动态库

动态链接是发生在运行时，而静态链接是发生在编译时。

当你编译一个静态库的时候，将其链接到可执行文件（也就是应用程序）或者将其链接到一个动态库。这有点像你取出那个静态库的内容，然后你把这些内容放入到其他的二进制数据中，它实际上在你的动态库或者在你的可执行文件中。

**静态链接允许更多的优化发生**，因为编译器和链接器在静态链接中可以得到更多的东西。

而动态链接，发生在运行时，这意味着**只有当你真正启动你的可执行文件时，你的动态库才会被加载**，所以它实际上不是可执行文件的一部分。

这种可执行文件的工作方式需要某些动态库（也就是外部文件）在运行之前就需要具备这些库。可执行文件知道动态链接的存在，作为一种需要。

动态链接GLFW库试试吧。



## 50.1 动态链接所需要的库

相比较于上一节所使用的静态链接，文件头不需要改变，因为文件头同时支持静态和动态链接；但对于函数之类的声明有一些不同之处。GLFW 跟许多库类似，同时支持静态和动态链接，使用相同的头文件。

- 首先将链接器中的依赖文件中正在使用的静态库替换成动态版本，即将glfw3.lib替换成glfw3dll.lib
- glfw3dll.lib 这个文件基本上就是一堆指向dll文件的指针。这样我们就不用再运行时去检索所有东西的位置，因此同时编译dll文件和这个文件很重要。
- 点击生成，会生成一个可执行文件，启动这个应用程序时得到错误消息：找不到glfw3.dll
- 此时我们需要告诉可执行文件我的glfw3.dll文件在哪里，简单的做法是将dll文件和exe文件放在一起，这样可执行文件就可以正常运行了。

这就是区别，我们链接到动态库，然后我们要确保在一个可访问的地方有dll文件，你可以在整个应用程序中，设置库搜索位置。但是可执行文件的根目录下，也就是包含你的程序的目录是一种自动搜索路径，如果你把它们放到同一个文件夹里就没有问题。



## 50.2 静态链接和动态链接之间的区别

头文件里，在返回类型和实际函数名之前定义了 GLFWAPI，里面会在不同系统下的输出 dll 函数的语法。有一些东西可以看看，为什么可以不需要 declspec dllimport，就能在 dll 文件中成功的链接到这些函数。

**ans:**

1. declspec(dllexport)与_declspec(dllimport)是相互呼应，只有在DLL内部用dllexport作了声明，才能在外部函数中用dllimport导入相关代码。
2. 如果vs中的dll项目内部的函数前面都没有 _declspec(dllexport)，则无法生成导出库lib，只有dll生成。
3. lib库原理上应该是不做链接过程的，我在一个lib项目上，故意犯下链接错误，编译并不报错。另外，我的一个lib项目，想把opencv的dll库包进来，成为一个包含了opencv功能的lib库，是不行的，因为在这个lib项目中，在vs编译器中都找不到linker选项，再次说明lib库不做链接。
4. 回到cherno的问题，因为这个项目已经用了引导库lib，所以不需要_declspec(dllimport)，就已经能够使用dll库了。lib就是起到定位dll的作用，所以用不用这个_declspec(dllimport)都无所谓。但如果此项目不用lib引导库，那必须使用_declspec(dllimport)来定位dll中的导出函数。
5. 预处理器中设置GLFW_DLL就相当于在源文件里面添加了#define GLFW_DLL，同时由于作者是WIN32平台就会有_WIN32这个宏定义，（在GFLW头文件那里面是一串关于GLFWAPI的宏定义）所以这种情况下就会将GLFWAPI定义为_declspec(dllimport)，相当于在声明函数时加上了_declspec(dllimport)，如果不加GLFW_DLL的宏定义就相当于啥都没有。作者就是想问声明函数时无论加不加_declspec(dllimport)，为什么都能正常运行，具体原因就是作者在链接器配置里面已经附加了glfw3dll.lib所以加不加_declspec(dllimport)效果一样都能正常运行，glfw3dll.lib的作用作者在前面有具体说明，当然推荐还是加上GLFW_DLL的定义（前面的注释说了，如果你的应用程序要链接这个DLL最好确保加上这个GLFW_DLL定义）



# 51. C++ 中创建与使用库

在 VStudio 中建立多个项目，以及创建一个库让所有的项目都能使用。如果你的项目规模很大的话，它不仅可以帮助您使用代码创建模板或库，并多次重用这些代码，还允许你混合语言。从一个完全空的文件夹开始，建立项目和库，文件夹命名为C++，项目名为game，库名为Engine（在解决方案game下创建新的解决方案Engine）。

- game 将成为我们的可执行文件，设置game的配置类型为“应用程序”，设置Engine的配置类型为静态库（.lib）然后写一些代码来测试它。
- 在两个项目下各添加一个名为src的文件夹，然后game项目创建一个Application.cpp文件，这基本就是我们应用的源文件也就是主文件。
- 在Engine项目下，创建一个新项目作为头文件名为Engine.h，还有一个cpp文件名为Engine.cpp。
- 具体代码内容见[D:\Cherno\C++\game]：在h文件里声明函数，然后在cpp文件中实现函数。最后在APP文件中调用Engine::PrintMessage

现在需要的是这些代码能够成功的执行和链接所有这些，写入到我的可执行文件。首先需要包含头文件。

- 包含Engine的头文件，一种方法是相对于当前的路径（#include "../../Engine/src/Engine.h"）还可以使用绝对路径，特别是编译器的包含路径
- 在game的属性界面的C++常规属性，在附加的包含目录中包括这个engine的源目录，$(SolutionDir)Engine\src; 展开后是：D:\Cherno\C++\game\Engine\src，这里的SolutionDir只是一个宏，它展开到该解决方案文件的位置或者具体的目录（也就是包含这个slu文件的目录）

……

**静态链接时所有的东西都被放入exe文件中，没有外部文件依赖**



# 52. C++ 中如何处理多返回值

 本节将讨论什么是元组 tuple，什么是 pair。

**问题**：有一个函数，需要返回两个字符串。在C++默认情况下，不能返回两种类型，Python可以。

传统的 C++ 里，你的函数可以返回一种类型，即一个特定的变量。所以我们的函数需要返回一个整数和一个字符串，就很困难。

如果有一个函数需要返回两个或多个相同类型的变量，则可以返回vector或数组。但如何返回不同类型的变量呢。

ans：比较好的方法是**创建一个结构体**，它可以包含这两种类型，如果还想要返回不同类型的东西，就可以把它添加到结构体中去返回它。



### Pair

utility 提供了 make_tuple 这样的工具，因此使用`std::make_pair(vs,fs)`创建一对东西

（其中vs和fs是string类型的），它自己就会返回tuple了，在这个tuple的例子中，模板参数是两个std::string，所以返回值应该写std::tuple\<std::string,std::string>，或者使用auto关键字代替 。

取参数时使用std::get<0>()，这样是取出第一个值\<>里面是索引。

因为我们有两个返回值，所以我们可以返回一个std::pair，它与tuple的唯一区别是我们不仅可以使用std::get，也可以简单的使用XXX.first和second。但它还是不太方便，因为它不知道变量的名称的类型。



### 结构体

需要返回多个变量时，最简便的方法还是使用结构体，创建一个结构体，和pair 差不多，但可以对变量命名。这里所有的东西都是在栈上创建的。当我们使用时只需要用 . 就可以。



# 53. C++ 的模板

模板，在其他语言里也被叫做“泛型”，但模板并不是泛型。模板有点像宏可以做很多事情，但泛型却非常受制于类型系统。

**模板**允许你定义一个可以根据你的用途进行编译，模板就是让编译器为你写代码基于你给定的规则。

例如定义了三个打印函数用于打印不同类型的value值（int float string），所有的东西几乎都一样，只有数据类型不同，这时我们可以将它们转变成一个模板。

## 语法

在返回类型之前，写上template，然后用typename给它取个名字：`template<typename T>` ，然后将Print函数那里的参数类型名改成T，就像下面这样：

```c++
template<typename T>
void Print(T value)
{
	std::cout << value << std::endl;
}

int main()
{//对于编译器能自动推导出来的类型可以不用尖括号<>写出来
	Print(5);//也可以显式的指定出来：Print<std::string>(5);//此时这个5会被报错，所以应该用int
	Print("hello");
	Print(5.5f);
	std::cin.get();
}
```

模板并不是实际存在的，当我们实际调用的时候，他才会被创建。也就是说只有当它基于模板的使用情况，发送到编译器，进行编译后才会具体化为真正的代码。

MSVC编译器不会对你不使用的模板错误进行报错，但有些编译器（eg：clang）会。



## 将模板用于类上

想要创建一个数组，它的大小是在编译时确定的，但我不能直接输入一个变量size之类的，因为这是一个栈分配的数组，所以在编译时就必须知道它的大小。

我们可以使用alloca（动态分配栈内存）或者其他可以动态的增加内存的方法。但如果只是想要**在栈上创建一个普通的C语言风格的数组**，因此这个size值要在编译时就要知道，而模板会在编译器被评估处理，所以很完美。

这里要做的是，将类转换成一个模板，但不用typename作为模板参数，我们可以使用int，然后将数量命名为N，然后在public里面返回N值。代码如下：

```C++
template<int N>
class Array //创建于栈上
{
private:
	int m_Array[N];
public:
	int GetSize() const { return N; }
};

int main()
{
	Array<5> array;
	std::cin.get();
}
```

利用同样的方式来实现一个参数类型和大小均可以指定的类，如下所示：

```C++

template<typename T,int N>
class Array //创建于栈上
{
private:
	T m_Array[N];
public:
	int GetSize() const { return N; }
};

int main()
{
	Array<char,5> array;
	std::cin.get();
}
```

- 这里创建的Array与标准数组类在C++标准模板库中的工作方式非常相似，类似于元编程：因为相比于实际的编程，我们的代码运行时，编译器在编译时实际在进行编程。
- **哪些情况适合使用模板**：
  1. 
  2. 

- 不要把模板用的太过于复杂。



# 54. C++的堆与栈内存的比较

C++的内存四区：栈区（stack），堆区（heap），全局区，代码区。

在应用程序启动后，操作系统将整个程序加载到内存，并分配一大堆物理ram，以便我们的实际应用程序可以运行。

栈和堆是ram中实际存在的两个区域。

- 栈通常是一个预定义大小的内存区域，通常为2兆字节左右。
- 堆也是一个预定义了默认值的区域，但堆的大小会随着应用程序的需求动态变化
- 但这两个内存区域的实际位置是完全一样的，都在ram中。
- 栈活跃在缓存中，因为需要不断的访问。但并不是存储在缓存中

栈和堆的不同之处在于，它如何为我们分配内存。

```C++
int value = 5;//在栈上分配一个整数并将其赋值为5
	//在堆内存上分配
	int* hvalue = new int;
	*hvalue = 5;
	//可见我们需要使用new关键字来在堆上分配。

创建数组时：
    int array[5];

int* harray = new int[5];

创建对象或类时
    Vector v;
Vector* hv = new Vector();  
```


## 注

1. RAM，ROM，Flash
2.    























